# OpenAPI Specification

#### Version 3.0.2
この文書の中では、キーワード "MUST"、 "MUST NOT"、 "REQUIRED"、 "SHALL"、 "SHALL NOT"、 "SHOULD"、 "SHOULD NOT"、 "RECOMMENDED"、 "NOT RECOMMENDED"、 "MAY"、および "OPTIONAL"は、すべて大文字で表記されている場合、そしてその時に限り、[BCP 14](https://tools.ietf.org/html/bcp14) [RFC2119](https://tools.ietf.org/html/rfc2119) [RFC8174](https://tools.ietf.org/html/rfc8174)に記述されている通りに解釈してください。

この文書は[The Apache License, Version 2.0](https://www.apache.org/licenses/LICENSE-2.0.html)の下でライセンスされています。

## 導入

OpenAPI Specification（OAS）は、RESTful APIの標準的な、言語に依存しないインターフェースを定義します。
このインターフェースは、人間とコンピュータの両方がソースコード、ドキュメント、またはネットワークトラフィックを確認することなくサービスの機能を見つけ、理解できるように定義します。
適切に定義されていれば、API利用者はAPIを理解し最小限の実装ロジックでリモートサービス（API）と通信することができます。

インターフェースを表示するための文書生成ツール、さまざまなプログラミング言語でサーバーやクライアントを生成するためのコード生成ツール、テストツール、その他多くのユースケースでOpenAPI definitionを使用できます。

## 目次
<!-- TOC depthFrom:1 depthTo:3 withLinks:1 updateOnSave:1 orderedList:0 -->

- [定義](#定義)
	- [OpenAPI Document](#oasDocument)
	- [Path Templating](#pathTemplating)
	- [Media Types](#mediaTypes)
	- [HTTP Status Codes](#httpCodes)
- [仕様](#仕様)
	- [バージョン](#バージョン)
	- [フォーマット](#フォーマット)
	- [ドキュメント構造](#documentStructure)
	- [データ型](#dataTypes)
	- [リッチテキストフォーマット](#richText)
	- [URLの相対参照](#relativeReferences)
	- [スキーマ](#schema)
		- [OpenAPI Object](#oasObject)
		- [Info Object](#infoObject)
		- [Contact Object](#contactObject)
		- [License Object](#licenseObject)
		- [Server Object](#serverObject)
		- [Server Variable Object](#serverVariableObject)
		- [Components Object](#componentsObject)
		- [Paths Object](#pathsObject)
		- [Path Item Object](#pathItemObject)
		- [Operation Object](#operationObject)
		- [External Documentation Object](#externalDocumentationObject)
		- [Parameter Object](#parameterObject)
		- [Request Body Object](#requestBodyObject)
		- [Media Type Object](#mediaTypeObject)
		- [Encoding Object](#encodingObject)
		- [Responses Object](#responsesObject)
		- [Response Object](#responseObject)
		- [Callback Object](#callbackObject)
		- [Example Object](#exampleObject)
		- [Link Object](#linkObject)
		- [Header Object](#headerObject)
		- [Tag Object](#tagObject)
		- [Reference Object](#referenceObject)
		- [Schema Object](#schemaObject)
		- [Discriminator Object](#discriminatorObject)
		- [XML Object](#xmlObject)
		- [Security Scheme Object](#securitySchemeObject)
		- [OAuth Flows Object](#oauthFlowsObject)
		- [OAuth Flow Object](#oauthFlowObject)
		- [Security Requirement Object](#securityRequirementObject)
	- [Specification Extensions](#specificationExtensions)
	- [Security Filtering](#securityFiltering)
- [Appendix A: Revision History](#revisionHistory)
	

<!-- /TOC -->

## 定義

##### <a name="oasDocument"></a>OpenAPIドキュメント
APIを定義または記述するドキュメント（またはドキュメントのセット）を指します。
OpenAPI definitionは、OpenAPI Specificationを使用し、それに準拠しています。

##### <a name="pathTemplating"></a>パステンプレート
パステンプレートとは、パスパラメータを使用してURLパスの一部を置換可能としてマークするための波括弧（{}）の使用法を指します。

##### <a name="mediaTypes"></a>メディアタイプ
メディアタイプの定義はいくつかのリソースにまたがっています。メディアタイプの定義は、[RFC6838](https://tools.ietf.org/html/rfc6838)に準拠すべきです（SHOULD）。

使用できるメディアタイプ定義の例:
```
  text/plain; charset=utf-8
  application/json
  application/vnd.github+json
  application/vnd.github.v3+json
  application/vnd.github.v3.raw+json
  application/vnd.github.v3.text+json
  application/vnd.github.v3.html+json
  application/vnd.github.v3.full+json
  application/vnd.github.v3.diff
  application/vnd.github.v3.patch
```
##### <a name="httpCodes"></a>HTTPステータスコード
HTTPステータスコードは、実行された操作のステータスを示すために使用されます。
利用可能なステータスコードは[RFC7231](https://tools.ietf.org/html/rfc7231#section-6)で定義されており、登録されているステータスコードは[IANA Status Code Registry](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml)に記載されています。

## 仕様

### バージョン

OpenAPI Specificationは[Semantic Versioning 2.0.0](https://semver.org/spec/v2.0.0.html)（semver）を使用してバージョン管理され、semverの仕様に準拠しています。

semverの`major`.`minor`部分（3.0など）は、OAS機能セットを示しています（SHALL）。
通常、*`.patch`* バージョンは、機能セットではなく、このドキュメント内の誤りの修正のみを行います。
OAS 3.0をサポートするツールは、すべてのOAS 3.0.\*バージョンと互換性があるべきです（SHOULD）。
ツールはパッチバージョンを考慮するべきではありません（SHOULD NOT）、例えば`3.0.0`と`3.0.1`を区別しません。

新しいOpenAPI Specificationのマイナーバージョンのリリース（マイナーバージョン番号を増やす）は、同じメジャーバージョンのより低いマイナーバージョンに開発されたツールを妨げるべきではありません（SHOULD NOT）。
したがって、`3.1.0`が現れたとしたら、`3.0.0`用に設計されたツールで使用可能であるべきです（SHOULD）。

OAS 3.\*.\*と互換性のあるOpenAPIドキュメントには、使用するOASのセマンティックバージョンを指定する必須フィールド[`openapi`](#oasVersion)が含まれています。
（OAS 2.0ドキュメントには、[`swagger`](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swaggerObject)という名前の最上位バージョンフィールドと値 `"2.0"`が含まれています。）

### フォーマット

OpenAPI Specificationに準拠するOpenAPIドキュメントは、それ自体がJSONオブジェクトです。
その表現にはJSON形式とYAML形式どちらを使用しても構いません。

たとえば、フィールドに配列値がある場合は、JSONの配列表現が使用されます。

```json
{
   "field": [ 1, 2, 3 ]
}
```
仕様書内のすべてのフィールド名は**大文字と小文字が区別されます**。
これは、明示的に**大文字と小文字が区別されない**ことを記されている場合を除いて、マップ内でキーとして使用されるすべてのフィールドに適用されます。

スキーマは、宣言された名前を持つ「固定フィールド」と、フィールド名の正規表現パターンを宣言する「パターンフィールド」の2種類のフィールドがあります。

パターンフィールドの名前は、それを含むオブジェクト内で一意でなければなりません（MUST）。

YAMLとJSONフォーマット間の変換を可能にするために、以下の制約を加えたYAMLバージョン[1.2](http://www.yaml.org/spec/1.2/spec.html)が推奨されます（RECOMMENDED）。

- タグは、[JSON Schema ruleset](http://www.yaml.org/spec/1.2/spec.html#id2803231)で許可されているものに限定しなければなりません（MUST）。
- YAMLマップで使用されるキーは、[YAML Failsafe schema ruleset](http://yaml.org/spec/1.2/spec.html#id2802346)で定義されているように、スカラー文字列に制限されなければなりません（MUST）。

**注**：APIは、YAMLまたはJSON形式のOpenAPIドキュメントで定義できますが、APIのリクエストおよびレスポンスのボディおよびその他の内容は、JSONまたはYAMLである必要はありません。

### <a name="documentStructure"></a>ドキュメント構造

OpenAPIドキュメントは、ユーザーの判断で単一のドキュメントで構成しても、複数の部分に分割してもよいです（MAY）。
分割する場合、[JSON Schema](http://json-schema.org)に書かれているように、分割された部分を参照するために`$ref`フィールドを仕様書内で使用しなければなりません（MUST）。

ルートOpenAPIドキュメントは`openapi.json`または`openapi.yaml`という名前にすることが推奨されます（RECOMMENDED）。

### <a name="dataTypes"></a>データ型

OASのプリミティブデータ型は、[JSON Schema Specification Wright Draft 00](https://tools.ietf.org/html/draft-wright-json-schema-00#section-4.2)でサポートされている型に基づいています。
型としての`integer`もサポートされており、小数部または指数部のないJSON numberとして定義されています。
`null`は型としてはサポートされていません（代替の解決策については[`nullble`](#schemaNullable)を参照してください）。
モデルは、JSON Schema Specification Wright Draft 00の拡張サブセットである[Schema Object](#schemaObject)を使用して定義されます。

<a name="dataTypeFormat"></a>プリミティブは修飾子プロパティ `format`を付加できます。
OASはいくつかの広く知られているフォーマットを使用して、使用されているデータ型を詳細に定義します。
ただし、ドキュメントのニーズをサポートするために、`format`プロパティはオープンな文字列値（`string`）プロパティであり、任意の値を取ることができます。
`"email"`、 `"uuid"`などの形式は、この仕様で定義されていなくても使用できます（MAY）。
`format`プロパティを伴わない型は、JSONスキーマの型定義に従います。
特定の`format`を認識しないツールは、`format`が指定されていない場合と同様に、デフォルトでその`type`のみを使用してもよいです（MAY）。

OASで定義されているフォーマットは以下の通りです

[`type`](#dataTypes) | [`format`](#dataTypeFormat) | コメント
------ | -------- | --------
`integer` | `int32` | 符号付32ビット
`integer` | `int64` | 符号付64ビット（longとして知られているもの）
`number` | `float` | |
`number` | `double` | |
`string` | | |
`string` | `byte` | base64でエンコードされた文字列
`string` | `binary` | 任意のオクテット列
`boolean` | | |
`string` | `date` | `full-date` - [RFC3339](https://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14)の定義の通り
`string` | `date-time` | `date-time` - [RFC3339](https://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14)の定義の通り
`string` | `password` | 入力を秘匿するようUIに促すヒント


### <a name="richText"></a>リッチテキストフォーマット
仕様書全体を通して、`description`フィールドはCommonMarkマークダウン形式をサポートするものとして記されます。
OpenAPIツールがリッチテキストをレンダリングする場合、[CommonMark 0.27](http://spec.commonmark.org/0.27/)に記されているように、少なくともマークダウン構文をサポートしなければなりません（MUST）。
セキュリティ上の問題に対処するために、ツールはCommonMarkの機能の一部を無視することを選択してもかまいません（MAY）。

### <a name="relativeReferences"></a>URLの相対参照

特に指定のない限り、URLであるすべてのプロパティは、[RFC3986](https://tools.ietf.org/html/rfc3986#section-4.2)で定義されているように相対参照してもかまいません（MAY）。
相対参照は、[`Server Object`](#serverObject)で定義されているURLをベースURIとして使用して解決されます。

`$ref`で使用されている相対参照は、現在のドキュメントのURLをベースURIとして使用して、[JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)に従って処理されます。
[Reference Object](#referenceObject)も参照してください。

### スキーマ

以下の説明では、フィールドが明示的に**REQUIRED**でない、あるいはMUSTやSHALLで記述されていない場合は、OPTIONALと見なすことができます。

#### <a name="oasObject"></a>OpenAPI Object

OpenAPI Objectが[OpenAPIドキュメント](#oasDocument)のルートドキュメントオブジェクトです。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="oasVersion"></a>openapi | `string` | **REQUIRED**. この文字列は、OpenAPIドキュメントが使用する[OpenAPI Specificationのバージョン](#バージョン)の[semantic version number](https://semver.org/spec/v2.0.0.html)でなければなりません。`openapi`フィールドは、OpenAPIドキュメントを解釈するためにツール仕様とクライアントによって使用されるべきです（SHOULD）。これは、APIの[`info.version`](#infoVersion)フィールドとは関係*ありません*。
<a name="oasInfo"></a>info | [Info Object](#infoObject) | **REQUIRED**. APIに関するメタデータを表します。メタデータは必要であればツールに利用してもよいです（MAY）。
<a name="oasServers"></a>servers | [[Server Object](#serverObject)] | APIサーバーへの接続情報を示すためのServer Objectの配列です。`servers`プロパティがない場合や、空の配列の場合はデフォルト値は[url](#serverUrl)の値が`/`の[Server Object](#serverObject)になります。
<a name="oasPaths"></a>paths | [Paths Object](#pathsObject) | **REQUIRED**. APIで利用できるパスと操作です。
<a name="oasComponents"></a>components | [Components Object](#componentsObject) | 仕様書のさまざまなスキーマを保持するための要素です。
<a name="oasSecurity"></a>security | [[Security Requirement Object](#securityRequirementObject)] | API全体でどのようなセキュリティメカニズムを使用できるかを宣言します。この一覧は使用できるSecurit Requirement Objectの選択肢です。Security Requirement Objectのうち1つだけでも満たせば、リクエストは許可されます。個々の操作ごとにこの定義をオーバーライドできます。
<a name="oasTags"></a>tags | [[Tag Object](#tagObject)] | 仕様書内で使用されるタグの一覧です。タグは追加のメタデータを保有できます。タグの順序は構文解析ツールでのタグの順序に反映するために使用できます。[Operation Object](#operationObject)で使用されている全てのタグを宣言する必要はありません。宣言されていないタグは、無作為にまたはツールのロジックに基づいて扱うことができます（MAY）。リスト内の各タグの名前は一意でなければなりません（MUST）。
<a name="oasExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | 追加の外部ドキュメント。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

#### <a name="infoObject"></a>Info Object

Info ObjectはAPIに関するメタデータを提供します。
クライアントは必要であればこのメタデータを使用してもよく（MAY）、
また、利便性のために編集ツールやドキュメント生成ツールもこれを表示してもよいです（MAY）。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="infoTitle"></a>title | `string` | **REQUIRED**. アプリケーションのタイトルです。
<a name="infoDescription"></a>description | `string` | アプリケーションの簡単な説明です。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="infoTermsOfService"></a>termsOfService | `string` | APIの利用規約のURLです。フォーマットはURLでなければなりません（MUST）。
<a name="infoContact"></a>contact | [Contact Object](#contactObject) | 公開するAPIの連絡先情報です。
<a name="infoLicense"></a>license | [License Object](#licenseObject) | 公開するAPIのライセンス情報です。
<a name="infoVersion"></a>version | `string` | **REQUIRED**. OpenAPIドキュメントのバージョンか、APIの実装のバージョンです。[OpenAPI Specification version](#oasVersion)とは異なります。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Info Objectの例

```json
{
  "title": "ペットショップアプリの例",
  "description": "ペットショップのサーバーの例です。",
  "termsOfService": "http://example.com/terms/",
  "contact": {
    "name": "API Support",
    "url": "http://www.example.com/support",
    "email": "support@example.com"
  },
  "license": {
    "name": "Apache 2.0",
    "url": "https://www.apache.org/licenses/LICENSE-2.0.html"
  },
  "version": "1.0.1"
}
```

```yaml
title: ペットショップアプリの例
description: ペットショップのサーバーの例です。
termsOfService: http://examp.com/terms/
contact:
  name: API Support
  url: http://www.example.com/support
  email: support@example.com
license:
  name: Apache 2.0
  url: https://www.apache.org/licenses/LICENSE-2.0.html
version: 1.0.1
```

#### <a name="contactObject"></a>Contact Object

公開するAPIの連絡先情報です。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="contactName"></a>name | `string` | 連絡担当者、組織の識別名。
<a name="contactUrl"></a>url | `string` | 連絡先情報を指すURL。URL形式でなければいけません（MUST）。
<a name="contactEmail"></a>email | `string` | 連絡担当者、組織のメールアドレス。メールアドレス形式でなければいけません（MUST）。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Contact Objectの例

```json
{
  "name": "APIサポート",
  "url": "http://www.example.com/support",
  "email": "support@example.com"
}
```

```yaml
name: APIサポート
url: http://www.example.com/support
email: support@example.com
```

#### <a name="licenseObject"></a>License Object

公開するAPIのライセンス情報。

##### 固定フィールド

Field Name | Type | Description
---|:---:|---
<a name="licenseName"></a>name | `string` | **REQUIRED**. The license name used for the API.
<a name="licenseUrl"></a>url | `string` | A URL to the license used for the API. MUST be in the format of a URL.

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### License Objectの例

```json
{
  "name": "Apache 2.0",
  "url": "https://www.apache.org/licenses/LICENSE-2.0.html"
}
```

```yaml
name: Apache 2.0
url: https://www.apache.org/licenses/LICENSE-2.0.html
```

#### <a name="serverObject"></a>Server Object

Server Objectはサーバーを表すオブジェクト。

##### Fixed Fields

Field Name | Type | Description
---|:---:|---
<a name="serverUrl"></a>url | `string` | **REQUIRED**. APIのホストのURL。このURLはサーバー変数をサポートしており、また、OpenAPIドキュメントを提供しているURLから相対的なURLであることを示すために相対パスを使用しても良い（MAY）。変数が`{`括弧`}`内で指定された時、変数置換が行われます。
<a name="serverDescription"></a>description | `string` | URLで指定されたホストを説明するオプションの文字列。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できる（MAY）。 
<a name="serverVariables"></a>variables | Map[`string`, [Server Variable Object](#serverVariableObject)] | 変数名とその値のマップ。サーバーのURL内の置換に使用される。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Server Objectの例

単一のサーバーは以下のように表現できます。

```json
{
  "url": "https://development.gigantic-server.com/v1",
  "description": "開発サーバー"
}
```

```yaml
url: https://development.gigantic-server.com/v1
description: 開発サーバー
```

以下の例はOpenAPI Object内の[`servers`](#oasServers)で複数サーバーを表現する方法を示しています。

```json
{
  "servers": [
    {
      "url": "https://development.gigantic-server.com/v1",
      "description": "開発サーバー"
    },
    {
      "url": "https://staging.gigantic-server.com/v1",
      "description": "ステージングサーバー"
    },
    {
      "url": "https://api.gigantic-server.com/v1",
      "description": "本番サーバー"
    }
  ]
}
```

```yaml
servers:
- url: https://development.gigantic-server.com/v1
  description: 開発サーバー
- url: https://staging.gigantic-server.com/v1
  description: ステージングサーバー
- url: https://api.gigantic-server.com/v1
  description: 本番サーバー
```

サーバー設定の変数の使い方は以下の通りです。

```json
{
  "servers": [
    {
      "url": "https://{username}.gigantic-server.com:{port}/{basePath}",
      "description": "本番APIサーバー",
      "variables": {
        "username": {
          "default": "demo",
          "description": "値はサービス提供者が設定します。この例では、サービス提供者は`gigantic-server.com`です。"
        },
        "port": {
          "enum": [
            "8443",
            "443"
          ],
          "default": "8443"
        },
        "basePath": {
          "default": "v2"
        }
      }
    }
  ]
}
```

```yaml
servers:
- url: https://{username}.gigantic-server.com:{port}/{basePath}
  description: 本番APIサーバー
  variables:
    username:
      # 注意 - ここにenumがない場合、これがopenな値であることを意味します。
      default: demo
      description: 値はサービス提供者が設定します。この例では、サービス提供者は`gigantic-server.com`です。
    port:
      enum:
        - '8443'
        - '443'
      default: '8443'
    basePath:
      # 先述のopenは、サービス提供者によって特別なbase pathが指定されることがあるということを意味します。ここではデフォルトはv2です。
      default: v2
```


#### <a name="serverVariableObject"></a>Server Variable Object

Server Variable ObjectはサーバーURLテンプレート置換のためのサーバー変数を表すオブジェクトです。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="serverVariableEnum"></a>enum | [`string`] | 限られた集合内の値にしか置き換えない場合に、使用できる文字列の列挙をします。
<a name="serverVariableDefault"></a>default | `string` |  **REQUIRED**. 置き換えに使用するデフォルトの値で、代替の値が与えられ*なかった*場合に使用されます（SHALL）。[Schema Object's](#schemaObject)のデフォルト値の扱いと異なることに注意してください。Schema Objectの場合はパラメータはオプションです。
<a name="serverVariableDescription"></a>description | `string` | サーバー変数の補足説明です。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

#### <a name="componentsObject"></a>Components Object

Components ObjectはOASの様々な側面に対応する再利用可能なオブジェクトを保持します。
Components Object内の全てのオブジェクトはComponents Object以外のプロパティから明示的に参照されない限り、APIに何も影響を与えません。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---|---
<a name="componentsSchemas"></a> schemas | Map[`string`, [Schema Object](#schemaObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Schema Objects](#schemaObject)を保有します。
<a name="componentsResponses"></a> responses | Map[`string`, [Response Object](#responseObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Response Objects](#responseObject)を保有します。
<a name="componentsParameters"></a> parameters | Map[`string`, [Parameter Object](#parameterObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Parameter Objects](#parameterObject)を保有します。
<a name="componentsExamples"></a> examples | Map[`string`, [Example Object](#exampleObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Example Objects](#exampleObject)を保有します。
<a name="componentsRequestBodies"></a> requestBodies | Map[`string`, [Request Body Object](#requestBodyObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Request Body Objects](#requestBodyObject)を保有します。
<a name="componentsHeaders"></a> headers | Map[`string`, [Header Object](#headerObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Header Objects](#headerObject)を保有します。
<a name="componentsSecuritySchemes"></a> securitySchemes| Map[`string`, [Security Scheme Object](#securitySchemeObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Security Scheme Objects](#securitySchemeObject)を保有します。
<a name="componentsLinks"></a> links | Map[`string`, [Link Object](#linkObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Link Objects](#linkObject)を保有します。
<a name="componentsCallbacks"></a> callbacks | Map[`string`, [Callback Object](#callbackObject) \| [Reference Object](#referenceObject)] | 再利用可能な[Callback Objects](#callbackObject)を保有します。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

上記全ての固定フィールドは正規表現`^[a-zA-Z0-9\.\-_]+$`にマッチしたキーを使用しなければなりません（MUST）。

フィールド名の例:

```
User
User_1
User_Name
user-name
my.org.User
```

##### Components Objectの例

```json
"components": {
  "schemas": {
    "GeneralError": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "Category": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "Tag": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    }
  },
  "parameters": {
    "skipParam": {
      "name": "skip",
      "in": "query",
      "description": "スキップするアイテム数",
      "required": true,
      "schema": {
        "type": "integer",
        "format": "int32"
      }
    },
    "limitParam": {
      "name": "limit",
      "in": "query",
      "description": "返却するレコードの最大数",
      "required": true,
      "schema" : {
        "type": "integer",
        "format": "int32"
      }
    }
  },
  "responses": {
    "NotFound": {
      "description": "エンティティが見つかりませんでした。"
    },
    "IllegalInput": {
      "description": "操作への不適切な入力です。"
    },
    "GeneralError": {
      "description": "汎用のエラー",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/GeneralError"
          }
        }
      }
    }
  },
  "securitySchemes": {
    "api_key": {
      "type": "apiKey",
      "name": "api_key",
      "in": "header"
    },
    "petstore_auth": {
      "type": "oauth2",
      "flows": {
        "implicit": {
          "authorizationUrl": "http://example.org/api/oauth/dialog",
          "scopes": {
            "write:pets": "あなたのアカウントのペット情報の変更",
            "read:pets": "あなたのペット情報の読み込み"
          }
        }
      }
    }
  }
}
```

```yaml
components:
  schemas:
    GeneralError:
      type: object
      properties:
        code:
          type: integer
          format: int32
        message:
          type: string
    Category:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
    Tag:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
  parameters:
    skipParam:
      name: skip
      in: query
      description: スキップするアイテム数
      required: true
      schema:
        type: integer
        format: int32
    limitParam:
      name: limit
      in: query
      description: 返却するレコードの最大数
      required: true
      schema:
        type: integer
        format: int32
  responses:
    NotFound:
      description: エンティティが見つかりませんでした。
    IllegalInput:
      description: 操作への不適切な入力です。
    GeneralError:
      description: 汎用のエラー
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/GeneralError'
  securitySchemes:
    api_key:
      type: apiKey
      name: api_key
      in: header
    petstore_auth:
      type: oauth2
      flows: 
        implicit:
          authorizationUrl: http://example.org/api/oauth/dialog
          scopes:
            write:pets: あなたのアカウントのペット情報の変更
            read:pets: あなたのペット情報の読み込み
```


#### <a name="pathsObject"></a>Paths Object

Paths Objectは個々のエンドポイントへの相対パスとそれらの操作を保有します。
URL全体は[`Server Object`](#serverObject)のURLにパスを追加することで構成されます。
Paths Objectは[ACL制約](#securityFiltering)によって空になることがあります（MAY）。

##### パターンフィールド

フィールドのパターン | 型 | 説明
---|:---:|---
<a name="pathsPath"></a>/{path} | [Path Item Object](#pathItemObject) | 特定のエンドポイントへの相対パスです。フィールド名はスラッシュから始まる必要があります（MUST）。URL全体は[`Server Object`](#serverObject)の`url`フィールドにこのパスを**追加したもの**で構成されます（相対URLの解決はありません）。[Pathtemplating](#pathTemplating)を利用できます。URLにマッチするとき、具体的な（テンプレートではない）URLがテンプレートのものよりも優先されます。同じ階層の異なるテンプレート名は同一視されるため存在してはいけません（MUST NOT）。曖昧なマッチングが発生した場合にどれを使用するかはツールの判断次第になります。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Path Templating Matching

次のようなパスがあるとき、`/pets/mine`が使用されるときは具体的な定義である`/pets/mine`が先にマッチします。

```
  /pets/{petId}
  /pets/mine
```

次のようなパスは同一視されるため正しくありません。

```
  /pets/{petId}
  /pets/{name}
```

次の例は曖昧なパス解決を引き起こします。

```
  /{entity}/me
  /books/{id}
```

##### Paths Objectの例

```json
{
  "/pets": {
    "get": {
      "description": "ユーザがアクセスできるシステム内のすべてのペットを返却します。",
      "responses": {
        "200": {          
          "description": "ペットの一覧",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/pet"
                }
              }
            }
          }
        }
      }
    }
  }
}
```

```yaml
/pets:
  get:
    description: ユーザがアクセスできるシステム内のすべてのペットを返却します。
    responses:
      '200':
        description: ペットの一覧
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/pet'
```

#### <a name="pathItemObject"></a>Path Item Object

Path Item Objectは単一のパスに対して実行できる操作を表します。
Path Item Objectは[ACL制限](#securityFiltering)によって空になることがあります（MAY）。
その際、パス自体はドキュメントとして依然公開されますが、読者はどのような操作・パラメータが使用できるかを知ることがありません。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="pathItemRef"></a>$ref | `string` | このPath Item Objectの定義に外部の定義を使用できます。参照された構造は[Path Item Object](#pathItemObject)の形式である必要があります（MUST）。参照先の定義とこのPath Item Object内の定義に矛盾がある場合の振る舞いは*未定義*です。
<a name="pathItemSummary"></a>summary| `string` | このパスの全ての操作に当てはまるような概要を文字列で記述します。この項目はオプションです。
<a name="pathItemDescription"></a>description | `string` | このパスの全ての操作に当てはまるような説明を文字列で記述します。この項目はオプションです。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="pathItemGet"></a>get | [Operation Object](#operationObject) | このパスへのGET操作の定義です。
<a name="pathItemPut"></a>put | [Operation Object](#operationObject) | このパスへのPUT操作の定義です。
<a name="pathItemPost"></a>post | [Operation Object](#operationObject) | このパスへのPOST操作の定義です。
<a name="pathItemDelete"></a>delete | [Operation Object](#operationObject) | このパスへのDELETE操作の定義です。
<a name="pathItemOptions"></a>options | [Operation Object](#operationObject) | このパスへのOPTIONS操作の定義です。
<a name="pathItemHead"></a>head | [Operation Object](#operationObject) | このパスへのHEAD操作の定義です。
<a name="pathItemPatch"></a>patch | [Operation Object](#operationObject) | このパスへのPATCH操作の定義です。
<a name="pathItemTrace"></a>trace | [Operation Object](#operationObject) | このパスへのTRACE操作の定義です。
<a name="pathItemServers"></a>servers | [[Server Object](#serverObject)] | このパスの全ての操作に対して代替に利用できる`server`の配列です。
<a name="pathItemParameters"></a>parameters | [[Parameter Object](#parameterObject) \| [Reference Object](#referenceObject)] | このパスの全ての操作に適用できるパラメーターの一覧です。このパラメーターはオペレーションの階層で上書きできますが、除外することはでいません。この一覧は重複するパラメーターを含んではいけません（MUST）。パラメータが一意であることは[`name`](#parameterName)と[`in`](#parameterIn)の組み合わせが一意であることにより定義されます。[OpenAPI Objectのコンポーネント内のパラメータ](#componentsParameters)で定義されたパラメータを参照するために[Reference Object](#referenceObject)を一覧で使用できます。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Path Item Object Example

```json
{
  "get": {
    "description": "IDに基づいてペットを返却します。",
    "summary": "IDでペットを見つけます。",
    "operationId": "getPetsById",
    "responses": {
      "200": {
        "description": "ペットのレスポンス",
        "content": {
          "*/*": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          }
        }
      },
      "default": {
        "description": "エラーペイロード",
        "content": {
          "text/html": {
            "schema": {
              "$ref": "#/components/schemas/ErrorModel"
            }
          }
        }
      }
    }
  },
  "parameters": [
    {
      "name": "id",
      "in": "path",
      "description": "使用するペットのIDです。",
      "required": true,
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "style": "simple"
    }
  ]
}
```

```yaml
get:
  description: IDに基づいてペットを返却します。
  summary: IDでペットを見つけます。
  operationId: getPetsById
  responses:
    '200':
      description: ペットのレスポンス
      content:
        '*/*' :
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Pet'
    default:
      description: エラーペイロード
      content:
        'text/html':
          schema:
            $ref: '#/components/schemas/ErrorModel'
parameters:
- name: id
  in: path
  description: 使用するペットのIDです。
  required: true
  schema:
    type: array
    style: simple
    items:
      type: string  
```

#### <a name="operationObject"></a>Operation Object

Operation ObjectはパスのAPI操作のひとつを説明するオブジェクトです。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="operationTags"></a>tags | [`string`] | APIドキュメントを管理するためのタグの一覧です。タグは操作の論理的なグルーピングや、あらゆる修飾として使用できます。
<a name="operationSummary"></a>summary | `string` | この操作が行うことの短い概要を記述します。
<a name="operationDescription"></a>description | `string` | 操作の振る舞いに関するより丁寧な説明を記述します。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="operationExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | この操作に関する追加の外部ドキュメントです。
<a name="operationId"></a>operationId | `string` | 操作を特定するための一意な文字列です。このIDはAPI内の全ての操作に対して一意でなければなりません（MUST）。operationIdの値は**大文字と小文字を区別します**。ツールやライブラリは操作を一意に特定するためにoperationIdを使用でき（MAY）、そのために、これは一般的なプログラミングの命名規則に従うことを推奨します（RECOMMENDED）。
<a name="operationParameters"></a>parameters | [[Parameter Object](#parameterObject) \| [Reference Object](#referenceObject)] | この操作に適用できるパラメータの一覧です。パラメータ[Path Item](#pathItemParameters)ですでに定義されている場合、新しい定義がそれを上書きします。ただし、すでに定義されているパラメータを除外することはできません。この一覧には重複したパラメータを含めてはいけません（MUST NOT）。パラメータが一意であることは[`name`](#parameterName)と[`in`](#parameterIn)の組み合わせが一意であることにより定義されます。[OpenAPI Objectのコンポーネント内のパラメータ](#componentsParameters)で定義されたパラメータを参照するために[Reference Object](#referenceObject)を一覧で使用できます。
<a name="operationRequestBody"></a>requestBody | [Request Body Object](#requestBodyObject) \| [Reference Object](#referenceObject) | この操作に適用できるリクエストボディです。`requestBody`はHTTP 1.1の仕様[RFC7231](https://tools.ietf.org/html/rfc7231#section-4.3.1)でリクエストボディの意味が明示的に定義されているHTTPメソッドしかサポートしません。それ以外のHTTP仕様がはっきりしないケースでは、利用者は`requestBody`を無視して解釈します（SHALL）。
<a name="operationResponses"></a>responses | [Responses Object](#responsesObject) | **REQUIRED**. この操作を事項することによって返却されうるレスポンスの一覧です。
<a name="operationCallbacks"></a>callbacks | Map[`string`, [Callback Object](#callbackObject) \| [Reference Object](#referenceObject)] | この親操作に関する非同期コールバックとして発生しうるもののマップ。キーはCallback Objectの一意な識別子です。マップ内の各値は[Callback Object](#callbackObject)で、API提供者から送られてくるリクエストと期待されるレスポンスを記述します。Callback Objectを特定するために使用するキーの値は実行時に評価される値で、コールバック操作に使うURLを特定します。
<a name="operationDeprecated"></a>deprecated | `boolean` | 操作が非推奨であることを示します。非推奨の操作についてAPI利用者は利用を控えるべきです（SOHULD）。デフォルト値は`false`です。
<a name="operationSecurity"></a>security | [[Security Requirement Object](#securityRequirementObject)] | この操作に使用できるセキュリティメカニズムの宣言です。この一覧は使用できるSecurit Requirement Objectの選択肢です。リクエストの認可にはSecurity Requirement Objectのうち一つを満たす必要があります。ここでの定義はトップレベルで宣言した全ての[`security`](#oasSecurity)フィールドを上書きします。空配列を使用することで、トップレベルで宣言したセキュリティを全て取り除いた状態になります。
<a name="operationServers"></a>servers | [[Server Object](#serverObject)] | この操作を提供する代替のサーバーの配列です。代替の`server`がPath Item Objectやトップレベルで定義されている場合、この値によって上書きされます。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Operation Objectの例

```json
{
  "tags": [
    "pet"
  ],
  "summary": "フォームのデータでストア内のペットを更新します。",
  "operationId": "updatePetWithForm",
  "parameters": [
    {
      "name": "petId",
      "in": "path",
      "description": "更新が必要なペットのID",
      "required": true,
      "schema": {
        "type": "string"
      }
    }
  ],
  "requestBody": {
    "content": {
      "application/x-www-form-urlencoded": {
        "schema": {
          "type": "object",
           "properties": {
              "name": { 
                "description": "ペットの更新後の名前",
                "type": "string"
              },
              "status": {
                "description": "ペットの更新後のステータス",
                "type": "string"
             }
           },
        "required": ["status"] 
        }
      }
    }
  },
  "responses": {
    "200": {
      "description": "ペットが更新されたとき",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    },
    "405": {
      "description": "メソッドが許可されていないとき",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    }
  },
  "security": [
    {
      "petstore_auth": [
        "write:pets",
        "read:pets"
      ]
    }
  ]
}
```

```yaml
tags:
- pet
summary: フォームのデータでストア内のペットを更新します。
operationId: updatePetWithForm
parameters:
- name: petId
  in: path
  description: 更新が必要なペットのID
  required: true
  schema:
    type: string
requestBody:
  content:
    'application/x-www-form-urlencoded':
      schema:
       properties:
          name: 
            description: ペットの更新後の名前
            type: string
          status:
            description: ペットの更新後のステータス
            type: string
       required:
         - status
responses:
  '200':
    description: ペットが更新されたとき
    content: 
      'application/json': {}
      'application/xml': {}
  '405':
    description: メソッドが許可されていないとき
    content: 
      'application/json': {}
      'application/xml': {}
security:
- petstore_auth:
  - write:pets
  - read:pets
```


#### <a name="externalDocumentationObject"></a>External Documentation Object

External Documentation Objectによりドキュメント拡張のための外部リソースへの参照が可能です。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="externalDocDescription"></a>description | `string` | 参照するドキュメントへの短い説明を記述します。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）.
<a name="externalDocUrl"></a>url | `string` | **REQUIRED**. 参照するドキュメントのURLです。値はURLの形式でなければいけません（MUST）。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### External Documentation Object Example

```json
{
  "description": "より詳しくはこちら",
  "url": "https://example.com"
}
```

```yaml
description: より詳しくはこちら
url: https://example.com
```

#### <a name="parameterObject"></a>Parameter Object

Parameter Objectは操作のパラメータの一つを記述します。

パラメータが一意であることは[`name`](#parameterName)と[`in`](#parameterIn)の組み合わせが一意であることにより定義されます。

##### パラメータの位置
`in`フィールドで指定されうるパラメータの位置は以下の4つです。
* path - [Path Templating](#pathTemplating)と共に使用し、リクエストのURLの一部がパラメータの値になります。これはホストやAPIのbase pathやホストを含みません。例えば、`/items/{itemId}`の場合、パスパラメータは`itemId`です。
* query - URLに付加されるパラメータです。例えば、`/items?id=###`の場合、クエリパラメータは`id`です。
* header - リクエストに求められているカスタムヘッダです。[RFC7230](https://tools.ietf.org/html/rfc7230#page-22)でヘッダ名は大文字と小文字を区別しないとされていることに注意してください。
* cookie - APIに特定のCookieを渡す場合に使用します。


##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="parameterName"></a>name | `string` | **REQUIRED**. パラメータの名前。パラメータ名は*大文字と小文字を区別します*。<ul><li>[`in`](#parameterIn)が`"path"`の場合、`name`フィールドは[Paths Object](#pathsObject)内の[path](#pathsPath)フィールドのパスセグメントに対応していなければなりません（MUST）。詳しくは[Path Templating](#pathTemplating)を確認してください。<li>[`in`](#parameterIn)が`"header"`で`name`フィールドが`"Accept"`、`"Content-Type"`または`"Authorization"`の場合、パラメータ定義は無視されます（SHALL）。<li>他のケースでは、`name`は[`in`](#parameterIn)で使用されるパラメータ名と対応します。</ul>
<a name="parameterIn"></a>in | `string` | **REQUIRED**. パラメータの位置を記述します。使用可能な値は"query"、"header"、"path"、"cookie"のいずれかです。
<a name="parameterDescription"></a>description | `string` | パラメータの簡単な説明です。使用法の例を書くこともできます。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を利用できます。
<a name="parameterRequired"></a>required | `boolean` | このパラメータが必須であることを示します。[parameter location](#parameterIn)が"path"の場合、このフィールドは必須で（**REQUIRED**）、その値は`true`でなければなりません（MUST）。それ以外の場合、このフィールドは任意で（MAY）、デフォルト値は`false`です。
<a name="parameterDeprecated"></a> deprecated | `boolean` | パラメータが非推奨であることを示し、使用しないように行こうすべきです（SHOULD）。デフォルト値は`false`です。
<a name="parameterAllowEmptyValue"></a> allowEmptyValue | `boolean` | 空の値を与えても良いかを示します。これは`query`のパラメータのみで使用でき、空の値のパラメータを渡してもよいことを示します。デフォルトの値は`false`です。[`style`](#parameterStyle)が使用されており、そのふるまいが`n/a`（シリアライズできない）の場合、`allowEmptyValue`は無視されます（SHALL）。このフィールドの使用は非推奨で（NOT RECOMMENDED）、以後のバージョンでは廃止される見込みです。

パラメータのシリアライズのルールは2つのうち1つです。
簡単な場合では、[`schema`](#parameterSchema)と[`style`](#parameterStyle)によって構造とパラメータの文法を記述できます。
The rules for serialization of the parameter are specified in one of two ways.
For simpler scenarios, a [`schema`](#parameterSchema) and [`style`](#parameterStyle) can describe the structure and syntax of the parameter.

フィールド名 | 型 | 説明
---|:---:|---
<a name="parameterStyle"></a>style | `string` | パラメータの値の型に対してどのようにシリアライズするかを記述します。デフォルト値は`in`の値によって異なり、`query`の場合は`form`、`path`の場合は`simple`、`header`の場合は`simple`、`cookie`の場合は`form`です。
<a name="parameterExplode"></a>explode | `boolean` | この値が`true`の場合、`array`型か`object`型の値は配列やmapのキーバリューペアの各値になります。他の型ではこのフィールドは何も影響を与えません。[`style`](#parameterStyle)が`form`の場合はデフォルト値は`true`です。それ以外の全ての`style`については、デフォルト値は`false`です。
<a name="parameterAllowReserved"></a>allowReserved | `boolean` | [RFC3986](https://tools.ietf.org/html/rfc3986#section-2.2)で定義されている予約文字`:/?#[]@!$&'()*+,;=`をパーセントエンコーディングなしで受け取るべきか（SHOULD）を決定します。このフィールドは`in`が`query`の場合のみ適用されます。デフォルト値は`false`です。
<a name="parameterSchema"></a>schema | [Schema Object](#schemaObject) \| [Reference Object](#referenceObject) | パラメータのシキーマを定義する型です。
<a name="parameterExample"></a>example | Any | メディアタイプの例です。例はスキーマとエンコーディングと合っているべきです（SHOULD）。`example`フィールドは`examples`フィールドと互いに共存しません。 さらに、`example`の値はスキーマで提供している例を _上書きします_。JSONやYAMLで自然に表現できないメディアタイプの場合、必要なところをエスケープしながら文字列に例を含めることができます。
<a name="parameterExamples"></a>examples | Map[ `string`, [Example Object](#exampleObject) \| [Reference Object](#referenceObject)] | メディアタイプの複数の例です。各例はパラメーターエンコーディングで指定された正しいフォーマットの`value`を持つべきです（SHOULD）。さらに、例を含んだ`schema`を参照している場合、`examples`の値がスキーマで提供している例を _上書きします_。

より複雑な場合では、[`content`](#parameterContent)フィールドでパラメータのメディアタイプとスキーマを定義できます。
パラメータは`schema`フィールドか`content`フィールドのどちらかを含まなければならず（MUST）、両方を含んではいけません。
`example`か`examples`を`schema`オブジェクトと両立している場合、例は指定されたシリアライズ方法に従わなければいけません（MUST）。


フィールド名 | 型 | 説明
---|:---:|---
<a name="parameterContent"></a>content | Map[`string`, [Media Type Object](#mediaTypeObject)] | パラメータの表現を含んだmapです。キーはメディアタイプで、値がパラメータの表現を記述します。このmapは1つのエントリしか含められません（MUST）。

##### スタイルの値

シンプルなパラメータをシリアライズする一般的な方法をサポートするために、`style`の値の集合が定義されています。

`style` | [`type`](#dataTypes) |  `in` | Comments
----------- | ------ | -------- | --------
matrix |  `primitive`, `array`, `object` |  `path` | [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.7)で定義されるPath形式のパラメータです。
label | `primitive`, `array`, `object` |  `path` | [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.5)で定義されるLabel形式のパラメータです。
form |  `primitive`, `array`, `object` |  `query`, `cookie` | [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.8)で定義されるForm形式のパラメータです。この選択はOpenAPI 2.0の`collectionFormat`を`csv`（`explode`が`false`の場合）や`multi`（`explode`が`true`の場合）にすることの後継です。
simple | `array` | `path`, `header` | [RFC6570](https://tools.ietf.org/html/rfc6570#section-3.2.2)で定義されるSimple形式のパラメータです。この選択はOpenAPI 2.0の`collectionFormat`を`csv`にすることの後継です。
spaceDelimited | `array` | `query` | スペースで分割された配列です。この選択はOpenAPI 2.0の`collectionFormat`を`ssv`にすることの後継です。
pipeDelimited | `array` | `query` | パイプで分割された配列です。この選択はOpenAPI 2.0の`collectoinFormat`を`pipes`にすることの後継です。
deepObject | `object` | `query` | フォームのパラメータでネストのあるオブジェクトをレンダリングするシンプルな方法を提供します。


##### Styleの例

`color`という名前のパラメータが以下のうちのひとつの値を持つものとします。

```
   string -> "blue"
   array -> ["blue","black","brown"]
   object -> { "R": 100, "G": 200, "B": 150 }
```
以下の表が各値のレンダリングの違いの例を示しています。

[`style`](#dataTypeFormat) | `explode` | `empty` | `string` | `array` | `object`
----------- | ------ | -------- | -------- | --------|-------
matrix | false | ;color | ;color=blue | ;color=blue,black,brown | ;color=R,100,G,200,B,150
matrix | true | ;color | ;color=blue | ;color=blue;color=black;color=brown | ;R=100;G=200;B=150
label | false | .  | .blue |  .blue.black.brown | .R.100.G.200.B.150
label | true | . | .blue |  .blue.black.brown | .R=100.G=200.B=150
form | false | color= | color=blue | color=blue,black,brown | color=R,100,G,200,B,150
form | true | color= | color=blue | color=blue&color=black&color=brown | R=100&G=200&B=150
simple | false | n/a | blue | blue,black,brown | R,100,G,200,B,150
simple | true | n/a | blue | blue,black,brown | R=100,G=200,B=150
spaceDelimited | false | n/a | n/a | blue%20black%20brown | R%20100%20G%20200%20B%20150
pipeDelimited | false | n/a | n/a | blue\|black\|brown | R\|100\|G\|200|G\|150
deepObject | true | n/a | n/a | n/a | color[R]=100&color[G]=200&color[B]=150

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Parameter Objectの例

64ビット整数の配列のヘッダパラメータは以下のように記述します。

```json
{
  "name": "token",
  "in": "header",
  "description": "ヘッダとして渡すトークン",
  "required": true,
  "schema": {
    "type": "array",
    "items": {
      "type": "integer",
      "format": "int64"
    }
  },
  "style": "simple"
}
```

```yaml
name: token
in: header
description: ヘッダとして渡すトークン
required: true
schema:
  type: array
  items:
    type: integer
    format: int64
style: simple
```

文字列値のパスパラメータは以下のように記述します。
```json
{
  "name": "username",
  "in": "path",
  "description": "フェッチするユーザ名",
  "required": true,
  "schema": {
    "type": "string"
  }
}
```

```yaml
name: username
in: path
description: フェッチするユーザ名
required: true
schema:
  type: string
```

オプションのクエリパラメータで、クエリパラメータを繰り返し宣言することで複数の値を受け付ける場合は以下のように記述します。
```json
{
  "name": "id",
  "in": "query",
  "description": "フェッチしたいオブジェクトの値",
  "required": false,
  "schema": {
    "type": "array",
    "items": {
      "type": "string"
    }
  },
  "style": "form",
  "explode": true
}
```

```yaml
name: id
in: query
description: フェッチしたいオブジェクトの値
required: false
schema:
  type: array
  items:
    type: string
style: form
explode: true
```

特定の型の未定義パラメータを受け付ける形式自由のクエリパラメータは以下のように記述します。
```json
{
  "in": "query",
  "name": "freeForm",
  "schema": {
    "type": "object",
    "additionalProperties": {
      "type": "integer"
    },
  },
  "style": "form"
}
```

```yaml
in: query
name: freeForm
schema:
  type: object
  additionalProperties:
    type: integer
style: form
```

シリアライズの定義のために`content`を使用して複雑なパラメータを記述するには以下のようにします。

```json
{
  "in": "query",
  "name": "coordinates",
  "content": {
    "application/json": {
      "schema": {
        "type": "object",
        "required": [
          "lat",
          "long"
        ],
        "properties": {
          "lat": {
            "type": "number"
          },
          "long": {
            "type": "number"
          }
        }
      }
    }
  }
}
```

```yaml
in: query
name: coordinates
content:
  application/json:
    schema:
      type: object
      required:
        - lat
        - long
      properties:
        lat:
          type: number
        long:
          type: number
```

#### <a name="requestBodyObject"></a>Request Body Object

Request Body Objectはひとつのリクエストボディを記述します。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="requestBodyDescription"></a>description | `string` | リクエストボディの簡単な説明です。使用法の例を書くこともできます。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="requestBodyContent"></a>content | Map[`string`, [Media Type Object](#mediaTypeObject)] | **REQUIRED**. リクエストボディの内容です。キーはメディアタイプか[media type range](https://tools.ietf.org/html/rfc7231#appendix-D)で、値でそれを説明します。複数のキーにマッチするリクエストに関しては、もっとも具体的なキーが適用されます。例えば、text/plainはtext/\*より優先されます。
<a name="requestBodyRequired"></a>required | `boolean` | リクエストボディがリクエストに必須かどうかを決定します。デフォルトは`false`です。


このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Request Bodyの例

モデル定義の参照を使ってリクエストボディを記述するには以下のようにします。
```json
{
  "description": "システムに追加するユーザ",
  "content": {
    "application/json": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": {
          "user" : {
            "summary": "ユーザの例", 
            "externalValue": "http://foo.bar/examples/user-example.json"
          } 
        }
    },
    "application/xml": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": {
          "user" : {
            "summary": "XMLでのユーザの例",
            "externalValue": "http://foo.bar/examples/user-example.xml"
          }
        }
    },
    "text/plain": {
      "examples": {
        "user" : {
            "summary": "プレーンテキストでのユーザの例",
            "externalValue": "http://foo.bar/examples/user-example.txt" 
        }
      } 
    },
    "*/*": {
      "examples": {
        "user" : {
            "summary": "他のフォーマットでのユーザの例",
            "externalValue": "http://foo.bar/examples/user-example.whatever"
        }
      }
    }
  }
}
```

```yaml
description: システムに追加するユーザ
content: 
  'application/json':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      user:
        summary: ユーザの例
        externalValue: 'http://foo.bar/examples/user-example.json'
  'application/xml':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      user:
        summary: XMLでのユーザの例
        externalValue: 'http://foo.bar/examples/user-example.xml'
  'text/plain':
    examples:
      user:
        summary: プレーンテキストでのユーザの例
        externalValue: 'http://foo.bar/examples/user-example.txt'
  '*/*':
    examples:
      user: 
        summary: 他のフォーマットでのユーザの例
        externalValue: 'http://foo.bar/examples/user-example.whatever'
```

文字列の配列であるようなボディパラメータを記述するには以下のようにします。
```json
{
  "description": "システムに追加するユーザ",
  "content": {
    "text/plain": {
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    }
  }
}
```

```yaml
description: システムに追加するユーザ
required: true
content:
  text/plain:
    schema:
      type: array
      items:
        type: string
```


#### <a name="mediaTypeObject"></a>Media Type Object

各Media Type Objectはスキーマとキーで指定されたメディアタイプでの例を提供します。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="mediaTypeSchema"></a>schema | [Schema Object](#schemaObject) \| [Reference Object](#referenceObject) | リクエストやレスポンス、パラメータの内容を定義するスキーマです。
<a name="mediaTypeExample"></a>example | Any | メディアタイプの例です。例は指定されたメディアタイプの正しい形式で記述すべきです（SHOULD）。`example`フィールドは`examples`フィールドと互いに共存しません。さらに、例を含んだ`schema`を参照している場合、`example`の値はスキーマで提供されている例を _上書きします_。
<a name="mediaTypeExamples"></a>examples | Map[ `string`, [Example Object](#exampleObject) \| [Reference Object](#referenceObject)] | メディアタイプの複数の例です。各例は存在する場合メディアタイプと指定されたスキーマに合致すべきです（SHOULD）。`examples`フィールドは`example`フィールドと互いに共存しません。さらに、例を含んだ`schema`を参照している場合、`example`の値はスキーマで提供されている例を _上書きします_。
<a name="mediaTypeEncoding"></a>encoding | Map[`string`, [Encoding Object](#encodingObject)] | プロパティ名とそのエンコーディング情報のmapです。プロパティ名であるキーは、スキーマ内にプロパティとして存在しなければなりません（MUST）。メディアタイプが`multipart`か`application/x-www-form-urlencoded`の場合はEncoding Objectは`requestBody`オブジェクトのみに適用されます（SHALL）。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Media Type Examples

```json
{
  "application/json": {
    "schema": {
         "$ref": "#/components/schemas/Pet"
    },
    "examples": {
      "cat" : {
        "summary": "猫の例",
        "value": 
          {
            "name": "Fluffy",
            "petType": "Cat",
            "color": "White",
            "gender": "male",
            "breed": "Persian"
          }
      },
      "dog": {
        "summary": "猫の名前をつけた犬の例",
        "value" :  { 
          "name": "Puma",
          "petType": "Dog",
          "color": "Black",
          "gender": "Female",
          "breed": "Mixed"
        },
      "frog": {
          "$ref": "#/components/examples/frog-example"
        }
      }
    }
  }
}
```

```yaml
application/json: 
  schema:
    $ref: "#/components/schemas/Pet"
  examples:
    cat:
      summary: 猫の例
      value:
        name: Fluffy
        petType: Cat
        color: White
        gender: male
        breed: Persian
    dog:
      summary: 猫の名前をつけた犬の例
      value:
        name: Puma
        petType: Dog
        color: Black
        gender: Female
        breed: Mixed
    frog:
      $ref: "#/components/examples/frog-example"
```

##### ファイルアップロードの考慮

バージョン2.0とは違い、`file`の入出力内容はOpenAPIでは他のスキーマタイプと同じセマンティクスで記述されます。
具体的には以下です。

```yaml
# base64エンコードされて送信される内容
schema:
  type: string
  format: base64
```

```yaml
# バイナリ（オクテットストリーム）で送信される内容
schema:
  type: string
  format: binary
```

これらの例はファイルアップロードの入力ペイロードやレスポンスペイロードにも適用されます。

`POST`操作でファイルを投稿する`requestBody`は以下のような形式があります。

```yaml
requestBody:
  content:
    application/octet-stream:
      # 全てのメディアタイプを受け入れるので、機能としては`*/*`と等価です。
      schema:
        # あらゆる型のバイナリファイル
        type: string
        format: binary
```

さらに、特定のメディアタイプは次のように記述できます（MAY）。

```yaml
# 複数の、特定のメディアタイプは以下のように記述できます。
requestBody:
  content:
      # pngかjpegのバイナリファイル
    'image/jpeg':
      schema:
        type: string
        format: binary
    'image/png':
      schema:
        type: string
        format: binary        
```

複数のファイルをアップロードするには、`multipart`メディアタイプを使用しなければなりません（MUST）。

```yaml
requestBody:
  content:
    multipart/form-data:
      schema:
        properties:
          # 全てのファイルに使用されるプロパティ名'file'
          file:
            type: array
            items:
              type: string
              format: binary

```

##### x-www-form-urlencodedリクエストボディのサポート

[RFC1866](https://tools.ietf.org/html/rfc1866)によるフォームURLエンコーディングを使用して内容を送信するには、以下の定義が使用できます。

```yaml
requestBody:
  content:
    application/x-www-form-urlencoded:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # RFC 1866をサポートするために複雑な型を文字列化
            type: object
            properties: {}
```

この例では、`requestBody`の内容はサーバに渡す際に[RFC1866](https://tools.ietf.org/html/rfc1866/)によって文字列化しなければなりません（MUST）。
さらに、`address`フィールドの複雑なオブジェクトも文字列化します。

`application/x-www-form-urlencoded`コンテンツタイプ内で複雑なオブジェクトを渡す場合、そのようなプロパティのデフォルトのシリアライズ方法は[`Encoding Object`](#encodingObject)の[`style`](#encodingStyle)で`form`として記述されています。

##### `multipart`コンテンツの特別な考慮

操作にリクエストボディを送信する際に`Content-Type`として`multipart/form-data`を使用することは一般的です。
バージョン2.0と異なり、`multipart`のcontentを使用している場合は`schema`は操作への入力パラメータを定義するために必須です（REQUIRED）。
これはマルチパートファイルのアップロードのメカニズムをサポートするだけでなく、複雑な構造をサポートします。

`multipart`タイプに渡す際、送信されるコンテンツの区間わけをするために境界を使用できます（MAY）。
そのため、`multipart`には以下のデフォルト`Content-Type`が定義されています。

* プロパティがプリミティブか、プリミティブの配列の場合、デフォルトのContent-Typeは`application/json`です。
* プロパティが複雑であるか、複雑な値の配列の場合、デフォルトのContent-Typeは`application/json`です。
* プロパティが`type: string`で`format:binary`か`format: base64`（ファイルオブジェクト）の場合、デフォルトのContent-Typeは`application/octet-stream`です。

例

```yaml
requestBody:
  content:
    multipart/form-data:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # オブジェクトに対するデフォルトのContent-Typeは`application/json`です。
            type: object
            properties: {}
          profileImage:
            # 文字列・バイナリに対するデフォルトのContent-Typeは`application/octet-stream`です。
            type: string
            format: binary
          children:
            # 配列に対するデフォルトのContent-Typeはその中身の型に基づきます（ここではtext/plain）。
            type: array
            items:
              type: string
          addresses:
            # 配列に対するデフォルトのContent-Typeはその中身の型に基づきます（objectなので、`application/json`）。
            type: array
            items:
              type: '#/components/schemas/Address'
```

`encoding`属性は`multipart`リクエストボディのパーツのシリアライズをコントロールできるように導入されました。
この属性は`multipart`と`appliction/x-www-form-urlencoded`のリクエストボディ _のみ_ に適用できます。

#### <a name="encodingObject"></a>Encoding Object

Encoding Objectはひとつのスキーマプロパティに適用する一つのエンコーディングを定義します。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="encodingContentType"></a>contentType | `string` | 特定のプロパティをエンコーディングするContent-Typeです。デフォルト値はプロパティの型によって異なります。`format`が`binary`であるような`string`に対しては`application/octet-stream`、他のプリミティブ型に対しては`text/plain`、`object`に対しては`application/json`、`array`に対してはデフォルトはその要素の型に従います。値は特定のメディアタイプ（例えば`application/json`）か、ワイルドカードメディアタイプ（例えば`image/*`）かコンマで区切った二つの型のリストが使用できます。
<a name="encodingHeaders"></a>headers | Map[`string`, [Header Object](#headerObject) \| [Reference Object](#referenceObject)] | ヘッダとして使用できる追加情報のmapでで、例えば`Content-Disposition`があります。`Content-Type`は別途記述し、このフィールドでは無視されます（SHALL）。このフィールドはリクエストボディのメディアタイプが`multipart`ではない場合無視されます（SHALL）。
<a name="encodingStyle"></a>style | `string` | 特定のフィールドの値がその型によってどのようにシリアライズされるかを記述します。詳しくは[`style`](#parameterStyle)フィールドの[Parameter Object](#parameterObject)をみてください。ふるまいはデフォルト値を含め`query`パラメータと同じです。このフィールドはリクエストボディのメディアタイプが`application/x-www-form-urlencoded`ではない場合に無視されます（SHALL）。
<a name="encodingExplode"></a>explode | `boolean` | `explode`が`true`の場合、`array`型や`object`型のフィールド値は配列やmapのキーバリューペアの各値の仕切られたパラメータを生成します。他の型に対してはこのフィールドはなにも影響を与えません。[`style`](#encodingStyle)が`form`のとき、デフォルト値は`true`です。`style`が他の値の時は、デフォルト値は`false`です。このフィールドはリクエストボディが`application/x-www-form-urlencoded`ではない場合に無視されます（SHALL）。
<a name="encodingAllowReserved"></a>allowReserved | `boolean` | パラメータ値が[RFC3986](https://tools.ietf.org/html/rfc3986#section-2.2)で定められる予約文字`:/?#[]@!$&'()*+,;=`をパーセントエンコーディングなしで受け付けるべきか（SHOULD）を決定します。デフォルト値は`false`です。このフィールドはリクエストボディのメディアタイプが`application/x-www-form-urlencoded`ではない場合は無視されます（SHALL）。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Encoding Objectの例

```yaml
requestBody:
  content:
    multipart/mixed:
      schema:
        type: object
        properties:
          id:
            # デフォルトはtext/plainです。
            type: string
            format: uuid
          address:
            #  デフォルトはapplication/jsonです。
            type: object
            properties: {}
          historyMetadata:
            # XMLフォーマットを明言する必要があります。
            description: XMLフォーマットのメタデータ
            type: object
            properties: {}
          profileImage:
            # デフォルトはapplicatoin/octet-streamで、イメージ型のみであることを明言する必要があります。
            type: string
            format: binary
      encoding:
        historyMetadata:
          # Content-TypeがUTF8でエンコードされたXMLであることを要求しています。
          contentType: application/xml; charset=utf-8
        profileImage:
          # pngとjpegのみ受け付けます。
          contentType: image/png, image/jpeg
          headers:
            X-Rate-Limit-Limit:
              description: 現在の期間で受け付けることができるリクエストの数。
              schema:
                type: integer
```

#### <a name="responsesObject"></a>Responses Object

操作の期待されるレスポンスを記述する場所です。
Response ObjectはHTTPステータスコードと期待されるレスポンスの関係を示します。

ドキュメントはありうる全てのHTTPレスポンスコードを網羅する必要はありません。
全てのレスポンスを事前に知ることができない場合があるためです。
しかし、ドキュメントは操作の成功と既知のエラーは網羅することが期待されます。

`default`は個別に記述されていない全てのHTTPコードのデフォルトのレスポンスオブジェクトとして使用できます（MAY）。

`Response OBject`は少なくともひとつのレスポンスコードを含まなければならず（MUST）、それは操作呼び出しの成功レスポンスであるべきです（SHOULD）。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="responsesDefault"></a>default | [Response Object](#responseObject) \| [Reference Object](#referenceObject) | HTTPステータスコードで明言されていないレスポンスに関するドキュメントです。このフィールドは未定義のレスポンスをカバーするために使用します。[Reference Object](#referenceObject)は[OpenAPI Objectのcomponents/responses](#componentsResponses)が定義したものにリンクすることができます。

##### パターンフィールド
フィールドパターン | 型 | 説明
---|:---:|---
<a name="responsesCode"></a>[HTTP Status Code](#httpCodes) | [Response Object](#responseObject) \| [Reference Object](#referenceObject) | すべての[HTTP status code](#httpCodes)かフィールド名として使用できますが、ステータスコードごとに1度ずつしか使用できません。そのHTTPステータスコードに対する期待されるレスポンスを記述します。[Reference Object](#referenceObject)は[OpenAPI Objectのcomponents/responses](#componentsResponses)で定義されたレスポンスにリンクすることができます。このフィールドはJSONとYAML間の互換性を保つために引用符で囲まなければなりません（例えば"200"）（MUST）。レスポンスコードの範囲を定義するために、このフィールドは大文字のワイルドカード文字`X`が使用できます。例えば、`2XX`は`[200-299]`の間の全てのレスポンスコードを表しています。範囲指定は`1XX`、`2XX`、`3XX`、`4XX`、`5XX`のみ使用できます。もしレスポンスが具体的なコードで定義されている場合、具体的なコードによる定義が範囲指定よりも優先されます。


このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Responses Objectの例

操作の成功の200レスポンスとエラーを意味する他のレスンポンスに対するデフォルト値の例。

```json
{
  "200": {
    "description": "返却されるペットです。",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/Pet"
        }
      }
    }
  },
  "default": {
    "description": "予期しないエラーです。",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/ErrorModel"
        }
      }
    }
  }
}
```

```yaml
'200':
  description: 返却されるペットです。
  content: 
    application/json:
      schema:
        $ref: '#/components/schemas/Pet'
default:
  description: 予期しないエラーです。
  content:
    application/json:
      schema:
        $ref: '#/components/schemas/ErrorModel'
```

#### <a name="responseObject"></a>Response Object
Response ObjectはAPI操作からのレスポンスのひとつや、設計時のレスポンスに基づいた操作への静的な`links`を記述します。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="responseDescription"></a>description | `string` | **REQUIRED**. レスポンスの短い説明。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="responseHeaders"></a>headers | Map[`string`, [Header Object](#headerObject)  \| [Reference Object](#referenceObject)] |  ヘッダ名とその定義をマップします。ヘッダ名は大文字と小文字を区別しないことが[RFC7230](https://tools.ietf.org/html/rfc7230#page-22)に記されています。レスポンスヘッダが`"Content-Type"`という名前で定義されている場合、無視されます（SHALL）。
<a name="responseContent"></a>content | Map[`string`, [Media Type Object](#mediaTypeObject)] | レスポンスとしてありえる内容の説明を含んだmapです。キーはメディアタイプか[media type range](https://tools.ietf.org/html/rfc7231#appendix-D)で、値がそれを説明します。レスポンスが複数のキーにマッチする場合、もっとも具体的なキーが有効になります。例：text/plainはtext/* を上書きします。
<a name="responseLinks"></a>links | Map[`string`, [Link Object](#linkObject) \| [Reference Object](#referenceObject)] | レスポンスの後に実行できる操作のリンクのmapです。mapのキーはリンクの短い名前で、[Component Objects](#componentsObject)の命名規約に従います。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Response Objectの例

複雑な型の配列のレスポンスの例。

```json
{
  "description": "複雑なオブジェクトの配列レスポンス",
  "content": {
    "application/json": {
      "schema": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/VeryComplexType"
        }
      }
    }
  }
}
```

```yaml
description: 複雑なオブジェクトの配列レスポンス
content: 
  application/json:
    schema: 
      type: array
      items:
        $ref: '#/components/schemas/VeryComplexType'
```

文字列型のレスポンスの例。

```json
{
  "description": "単純な文字列レスポンス",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  }

}
```

```yaml
description: 単純な文字列レスポンス
content:
  text/plain:
    schema:
      type: string
```

ヘッダつきのプレーンテキストレスポンスの例。

```json
{
  "description": "シンプルな文字列レスポンス",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  },
  "headers": {
    "X-Rate-Limit-Limit": {
      "description": "現在の期間で実行できるリクエスト回数",
      "schema": {
        "type": "integer"
      }
    },
    "X-Rate-Limit-Remaining": {
      "description": "現在の期間で残っているリクエスト回数",
      "schema": {
        "type": "integer"
      }
    },
    "X-Rate-Limit-Reset": {
      "description": "現在の期間の残り秒数",
      "schema": {
        "type": "integer"
      }
    }
  }
}
```

```yaml
description: シンプルな文字列レスポンス
content:
  text/plain:
    schema:
      type: string
    example: 'whoa!'
headers:
  X-Rate-Limit-Limit:
    description: 現在の期間で実行できるリクエスト回数
    schema:
      type: integer
  X-Rate-Limit-Remaining:
    description: The number of remaining requests in the current period
    schema:
      type: integer
  X-Rate-Limit-Reset:
    description: The number of seconds left in the current period
    schema:
      type: integer
```

戻り値がないレスポンスの例。

```json
{
  "description": "オブジェクトが作成されました"
}
```

```yaml
description: オブジェクトが作成されました
```

#### <a name="callbackObject"></a>Callback Object

この親操作に関する非同期コールバックとして発生しうるもののマップです。
マップ内の各値はAPI提供者が送信しうるリクエストと期待するレスポンスの集合を記述した[Path Item Object](#pathItemObject)です。
Callback Objectを識別するためのキーは式（expression）で、実行時に評価され、コールバック操作を行うためのURLとみなされます。

##### パターンフィールド
フィrールドパターン | 型 | 説明
---|:---:|---
<a name="callbackExpression"></a>{expression} | [Path Item Object](#pathItemObject) | コールバックリクエストと期待するレスポンスを定義するためのPath Item Objectです。 [完全な例](../examples/v3.0/callback-example.yaml)があります。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### キーの式（expression）

[Path Item Object](#pathItemObject)を識別するキーはHTTPリクエスト・レスポンスの実行時に評価され、コールバックリクエストに使われるURLを識別する[実行時式（runtime expression）](#runtimeExpression)です。
簡単な例として、`$request.bodu#/url`が挙げられます。
しかし、[実行時式](#runtimeExpression)を使って完全なHTTPメッセージにアクセスできます。
これはJSON Pointer [RFC6901](https://tools.ietf.org/html/rfc6901)が参照できるあらゆるボディの一部を含みます。

例えば、次のようなHTTPリクエストがある場合、

```http
POST /subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning HTTP/1.1
Host: example.org
Content-Type: application/json
Content-Length: 187

{
  "failedUrl" : "http://clientdomain.com/failed",
  "successUrls" : [
    "http://clientdomain.com/fast",
    "http://clientdomain.com/medium",
    "http://clientdomain.com/slow"
  ] 
}

201 Created
Location: http://example.org/subscription/1
```

次の例はコールバック操作がパスパラメータ`eventType`とクエリパラメータ`queryUrl`を持つ場合に様々な式がどのように評価されるかを示しています。

式 | 値 
---|:---
$url | http://example.org/subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning
$method | POST
$request.path.eventType | myevent
$request.query.queryUrl | http://clientdomain.com/stillrunning
$request.header.content-Type | application/json
$request.body#/failedUrl | http://clientdomain.com/failed
$request.body#/successUrls/2 | http://clientdomain.com/medium
$response.header.Location | http://example.org/subscription/1


##### Callback Objectの例

次の例はリクエストボディの`id`と`email`フィールドで指定されたURLへのコールバックを示しています。

```yaml
myWebhook:
  'http://notificationServer.com?transactionId={$request.body#/id}&email={$request.body#/email}':
    post:
      requestBody:
        description: コールバックペイロード
        content: 
          'application/json':
            schema:
              $ref: '#/components/schemas/SomePayload'
      responses:
        '200':
          description: webhookが問題なく処理され、リトライは行われません
```


#### <a name="exampleObject"></a>Example Object

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="exampleSummary"></a>summary | `string` | 例についての短い説明
<a name="exampleDescription"></a>description | `string` | 例についての長い説明。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="exampleValue"></a>value | Any | 埋め込みリテラルの例。`value`フィールドと`externalValue`フィールドは互いに排他です。JSONやYAMLで自然に表現できないメディアタイプについては、例を含んだ文字列値を適切なエスケープと共に使用してください。
<a name="exampleExternalValue"></a>externalValue | `string` | リテラルの例へのURL。これによりJSONやYAMLに簡単に含められないような参照例を使用できます。`value`フィールドと`exeternalValue`は互いに排他です。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

すべての場合において、例の値は対応する値の型スキーマに対応していることが期待されます。
ツールの実装は自動で適合性をバリデーションし、適合しないものを棄却してもよいです（MAY）。

##### Example Objectの例

モデル内の例

```yaml
schemas:
  properties:
    name:
      type: string
      examples:
        name:
          $ref: http://example.org/petapi-examples/openapi.json#/components/examples/name-example
```

リクエストボディの例

```yaml
requestBody:
  content:
    'application/json':
      schema:
        $ref: '#/components/schemas/Address'
      examples: 
        foo:
          summary: foo例
          value: {"foo": "bar"}
        bar:
          summary: A bar example
          value: {"bar": "baz"}
    'application/xml':
      examples: 
        xmlExample:
          summary: XMLの例
          externalValue: 'http://example.org/examples/address-example.xml'
    'text/plain':
      examples:
        textExample: 
          summary: これはテキストの例
          externalValue: 'http://foo.bar/examples/address-example.txt'
```

パラメータの例

```yaml
parameters:
  - name: 'zipCode'
    in: 'query'
    schema:
      type: 'string'
      format: 'zip-code'
      examples:
        zip-example: 
          $ref: '#/components/examples/zip-example'
```

レスポンスの例

```yaml
responses:
  '200':
    description: 車の予約が完了しました
    content: 
      application/json:
        schema:
          $ref: '#/components/schemas/SuccessResponse'
        examples:
          confirmation-success:
            $ref: '#/components/examples/confirmation-success'
```


#### <a name="linkObject"></a>Link Object

`Link object`はレスポンスにつくことのある設計時リンクを表現します。
リンクの存在は呼び出し側が実行に成功することを保証せず、レスポンスと他の操作の既知の関係や横断的なメカニズムを提供します。

_動的な_ リンク（レスポンスペイロード**内**で提供されるリンク）と異なり、OASのリンクメカニズムは実行時レスポンス内のリンク情報を要求しません。

リンクの生成や、実行説明の提供のため、[実行時式](#runtimeExpression)が操作内の値にアクセスしたり、それをリンクされた操作の実行のパラメータとして使用するために使用できます。

##### 固定フィールド

フィールド名 | 型 | 説明
---|:---:|---
<a name="linkOperationRef"></a>operationRef | `string` | OAS操作への相対または絶対参照です。このフィールドは`operationId`と互いに排他的で、[Operation Object](#operationObjet)を指していなければなりません（MUST）。OpenAPI definition内に存在する[Operation Object](#operationObject)の指定に相対の`operationRef`の値を使用できます（MAY）。 
<a name="linkOperationId"></a>operationId  | `string` | 一意な`operationId`で定義された _存在し_ 、解決できるOAS操作の名前です。このフィールドは`operationRef`フィールドと互いに排他的です。
<a name="linkParameters"></a>parameters   | Map[`string`, Any \| [{expression}](#runtimeExpression)] | `operationId`や`operationRef`で指定された操作に渡すパラメータを表現したマップです。キーは使用するパラメータの名前で、値は評価してリンクされた操作に渡す式か定数で指定できます。操作内の異なる位置の同名パラメータのために[parameter location](#parameterIn)で装飾でき、`[{in}.{name}]`のように指定できます（例: path.id）。
<a name="linkRequestBody"></a>requestBody | Any \| [{expression}](#runtimeExpression) | 指定の操作を呼び出す際のリクエストボディのリテラル値か[{式（expression）}](#runtimeExpression)。
<a name="linkDescription"></a>description  | `string` | リンクの説明です。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます。
<a name="linkServer"></a>server       | [Server Object](#serverObject) | 指定の操作に使用されるServer Objectです。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

リンクされる操作を`operationRef`か`operationId`のどちらかで特定しなければなりません（MUST）。
`operationId`の場合、それはOASドキュメント内で一意でなければなりません（MUST）。
名前衝突の可能性を考慮して外部参照を含む仕様書には`operationRef`を使った文法が好ましいです。

##### 例

`$request.path.id`がリンクされた操作のリクエストパラメータに渡されているリクエスト操作からのリンクの処理です。

```yaml
paths:
  /users/{id}:
    parameters:
    - name: id
      in: path
      required: true
      description: userIdのようなユーザの識別子
      schema:
        type: string
    get:
      responses:
        '200':
          description: 返却されるユーザ
          content:
            application/json:
              schema:
                type: object
                properties:
                  uuid: # the unique user id
                    type: string
                    format: uuid
          links:
            address:
              # 指定リンクのoperationId
              operationId: getUserAddress
              parameters:
                # パスパラメータ`id`から`id`フィールドを取得
                userId: $request.path.id
  # 指定の操作のpath item
  /users/{userid}/address:
    parameters:
    - name: userid
      in: path
      required: true
      description: userIdのようなユーザの識別子
      schema:
        type: string
    # リンクされた操作
    get:
      operationId: getUserAddress
      responses:
        '200':
          description: ユーザーの住所
```

実行時式の評価に失敗した場合、指定の操作にはパラメータ値が渡されません。

リンクされた操作を扱うためにレスポンスボディからの値がを使用できます。

```yaml
links:
  address:
    operationId: getUserAddressByUUID
    parameters:
      # `uuid`フィールドをレスポンスボディの`uuid`フィールドから取得
      userUuid: $response.body#/uuid
```

クライアントは全てのリンクについてクライアント自身の判断で利用します。
リンクの呼び出しが成功するための権限や性能は関係の存在だけによっては保証されません。


##### OperationRefの例

`operationId`への参照が不可能である（MAY NOT）とき（`operationId`はオプションの値です）、
参照は相対の`operationRef`によっても作成できます（MAY）。

```yaml
links:
  UserRepositories:
    # '#/components/schemas/repository'の配列を返す
    operationRef: '#/paths/~12.0~1repositories~1{username}/get'
    parameters:
      username: $response.body#/username
```

or an absolute `operationRef`:

```yaml
links:
  UserRepositories:
    # '#/components/schemas/repository'の配列を返す
    operationRef: 'https://na2.gigantic-server.com/#/paths/~12.0~1repositories~1{username}/get'
    parameters:
      username: $response.body#/username
```

JSON参照を使用する時、`operationRef`の使用には _エスケープされた（前向き）スラッシュ_ が必要なことに注意してください。


##### <a name="runtimeExpression"></a>Runtime Expressions

実行時式（runtime expression）により、実際のAPI呼び出し中HTTPメッセージ内でのみ使用できるような情報に基づいて値を定義できます。
この仕組みは[Link Objects](#linkObject)や[Callback Objects](#callbackObject)で使用されています。

実行時式は次の文法[ABNF](https://tools.ietf.org/html/rfc5234)により定義されます。

```
      expression = ( "$url" | "$method" | "$statusCode" | "$request." source | "$response." source )
      source = ( header-reference | query-reference | path-reference | body-reference )  
      header-reference = "header." token
      query-reference = "query." name  
      path-reference = "path." name
      body-reference = "body" ["#" fragment]
      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)  
      name = *( char )
      char = as per RFC [7159](https://tools.ietf.org/html/rfc7159#section-7)
      token = as per RFC [7230](https://tools.ietf.org/html/rfc7230#section-3.2.6)
```

識別子`name`は大文字と小文字を区別しますが、`token`は大文字と小文字を区別しません。

下の表に実行時式の例とそれらを値の中で使用する例を示しています。

##### <a name="runtimeExpressionExamples"></a>例

取得元 | 式の例 | 備考
---|:---|:---|
HTTP メソッド            | `$method`         | `$method`が取りうる値はHTTPメソッドとして使用できるものです。
要求されたメディアタイプ | `$request.header.accept`        |  
リクエストパラメータ      | `$request.path.id`        | リクエストパラメータは`parameters`で宣言されていなければならず（MUST）、そうでなければ評価されません。これはリクエストヘッダも同様です。
リクエストボディのフィールド   | `$request.body#/user/uuid`   | ペイロードを受け取る操作の、`requestBody`の一部か全体に対して参照できます。
リクエストURL            | `$url`            |  
レスポンス値         | `$response.body#/status`       |  ペイロードを受け取る操作の、レスポンスボディの一部か全体に対して参照できます。
レスポンスヘッダ        | `$response.header.Server` |  ヘッダの値ひとつのみを指定できます。

実行時式は参照している値の型を保存します。
波括弧`{}`で囲むことで式を文字列に埋め込むことができます。

#### <a name="headerObject"></a>Header Object

Header Objectは[Parameter Object](#parameterObject)の構造を引き継いでいますが、次の変更点があります。

1. `name`を指定してはならず（MUST NOT）、対応する`headerd`マップで与えられます。
1. `in`は指定してはならず（MUST NOT）、暗黙的に`header`になります。
1. 位置（`in`）の影響を受ける性質は全て、位置が`header`であるときと対応していなければなりません（MUST）。（例えば、[`style`](#parameterStyle)）


##### Header Objectの例

`integer`型の単純なヘッダ

```json
{
  "description": "この期間に実行できるリクエストの回数",
  "schema": {
    "type": "integer"
  }
}
```

```yaml
description: この期間に実行できるリクエストの回数
schema:
  type: integer
```

#### <a name="tagObject"></a>Tag Object

Tag Objectは[Operation Object](#operationObject)に使用されているタグのメタ情報を追加します。
Operation Objectで定義されたタグに対してTag Objectを定義するのは必須ではありません。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="tagName"></a>name | `string` | **REQUIRED**. タグの名前です。
<a name="tagDescription"></a>description | `string` | タグの短い説明です。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます。
<a name="tagExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | このタグに関する追加の外部ドキュメント。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Tag Objectの例

```json
{
	"name": "pet",
	"description": "ペット操作"
}
```

```yaml
name: pet
description: ペット操作
```


#### <a name="referenceObject"></a>Reference Object

仕様書内で他の外部・内部コンポーネントを参照する単純なオブジェクトです。

Reference Objectは[JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)で定義され、構造・振る舞い・規則もそれに従います。

この使用について、参照の解決はJSON Schema specificationではなくJSON Reference specificationで行われます。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="referenceRef"></a>$ref | `string` | **REQUIRED**. 参照文字列。

このオブジェクトは追加フィールドによって拡張できず、あらゆるフィールドは無視されます（SHALL）。
This object cannot be extended with additional properties and any properties added SHALL be ignored.

##### Reference Objectの例

```json
{
	"$ref": "#/components/schemas/Pet"
}
```

```yaml
$ref: '#/components/schemas/Pet'
```

##### 相対スキーマドキュメントの例
```json
{
  "$ref": "Pet.json"
}
```

```yaml
$ref: Pet.yaml
```

##### 埋め込みスキーマのある相対ドキュメントの例
```json
{
  "$ref": "definitions.json#/Pet"
}
```

```yaml
$ref: definitions.yaml#/Pet
```

#### <a name="schemaObject"></a>Schema Object

Schema Objectにより入力や出力のデータ型を定義できます。
これらの型にはオブジェクトだけでなく、プリミティブや配列も使用できます。
このオブジェクトは[JSON Schema Specification Wright Draft 00](http://json-schema.org/)の拡張サブセットです。

このプロパティに関してより詳しくは、[JSON Schema Core](https://tools.ietf.org/html/draft-wright-json-schema-00)や[JSON Schema Validation](https://tools.ietf.org/html/draft-wright-json-schema-validation-00)を確認してください。
明示されていなければ、プロパティ定義はJSON Schemaに従います。

##### Properties 

次のプロパティはJson Schema定義から直接とられ、同じ仕様に従います。

- title
- multipleOf
- maximum
- exclusiveMaximum
- minimum
- exclusiveMinimum
- maxLength
- minLength
- pattern ([ECMA 262 regular expression](https://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5)にしたがって文字列は正しい正規表現であるべきです（SHOULD）。)
- maxItems
- minItems
- uniqueItems
- maxProperties
- minProperties
- required
- enum

The following properties are taken from the JSON Schema definition but their definitions were adjusted to the OpenAPI Specification. 
次のプロパティはJSON Schema定義からとられますが、その定義はOpenAPI Specificationによって調整されます。
- type - 値は文字列でなければなりません（MUST）。配列による複数の型指定はサポートされません。
- allOf - インラインでも参照でもスキーマは[Schema Object](#schemaObject)でなければならず（MUST）、標準のJSON Schemaではありません。
- oneOf - インラインでも参照でもスキーマは[Schema Object](#schemaObject)でなければならず（MUST）、標準のJSON Schemaではありません。
- anyOf - インラインでも参照でもスキーマは[Schema Object](#schemaObject)でなければならず（MUST）、標準のJSON Schemaではありません。
- not - インラインでも参照でもスキーマは[Schema Object](#schemaObject)でなければならず（MUST）、標準のJSON Schemaではありません。
- items - 値は配列ではなくオブジェクトでなければなりません（MUST）。インラインでも参照でもスキーマは[Schema Object](#schemaObject)でなければならず（MUST）、標準のJSON Schemaではありません。`items`は`type`が`array`の場合存在しなければなりません（MUST）。
- properties - プロパティ定義は[Schema Object](#schemaObject)でなければならず（MUST）、インライン・参照にかかわらず標準JSON Schemaではありません。
- additionalProperties - 値は論理値かオブジェクトが使用できます。インラインでも参照でもスキーマは[Schema Object](#schemaObject)でなければならず（MUST）、標準のJSON Schemaではありません。JSON Schemaとの一貫性のため、`additionalProperties`はデフォルトで`true`です。
- description - リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)が使用できます（MAY）.
- format - 詳しくは[Data Type Formats](#dataTypeFormat)を確認してください。JSON Schemaで定義されたフォーマットを使用していますが、OASはいくつかの事前定義フォーマットを提供します。
- default - スキーマの値として提供されなかった入力について利用者にデフォルト値とみなすものです。JSON Schemaと違い、同じレベルで定義されたSchema Objectの型定義にあっていなければなりません（MUST）。例えば、`type`が`string`のとき、`default`として`"foo"`を使用できますが、`1`は使用できません。

代替として、Schema Objectが使用できる場所ではどこでも、[Reference Object](#referenceObject)が使用できます。
これによりインラインで定義する代わりに定義を参照できます。

ここで言及されていないJSON Schema specificationで定義された追加プロパティは厳密にサポートされません。

JSON Schemaサブセットフィールドとは異なり、次のフィールドはスキーマドキュメントとして使用できます（MAY）。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="schemaNullable"></a>nullable | `boolean` | `null`値を定義されたスキーマに送ることを許可します。デフォルト値は`false`です。
<a name="schemaDiscriminator"></a>discriminator | [Discriminator Object](#discriminatorObject) | ポリモーフィズムのサポートを追加します。この`discriminator`はペイロード記述を満たす他のスキーマと区別するためのオブジェクト名です。より詳しくは[コンポジションと継承](#schemaComposition)を確認してください。
<a name="schemaReadOnly"></a>readOnly | `boolean` | スキーマ`"properties"`定義にのみ関係します。フィールドが「読み込み専用」であることを示します。これはレスポンスの一部として送られることがありますが（MAY）、リクエストの一部として送られるべきではない（SHOULD NOT）ことを意味します。`readOnly`が`true`となっていて`required`リスト内にあるフィールドは、`required`はレスポンスにのみ反映されます。フィールドに`readOnly`と`writeOnly`両方を指定することはできません（MUST NOT）。デフォルト値は`false`です。
<a name="schemaWriteOnly"></a>writeOnly | `boolean` | スキーマ`"properties"`定義にのみ関係します。フィールドが「書き込み専用」であることを示します。そのため、リクエストの一部として送られることがありますが（MAY）、レスポンスの一部として送られるべきではありません（SHOULD NOT）。`readOnly`が`true`となっていて`required`リスト内にあるフィールドは、`required`はリクエストにのみ反映されます。フィールドに`readOnly`と`writeOnly`両方を指定することはできません（MUST NOT）。デフォルト値は`false`です。
<a name="schemaXml"></a>xml | [XML Object](#xmlObject) | プロパティスキーマでのみ使用できます（MAY）。これはルートスキーマでは効果がありません。このプロパティのXML表現を記述するための追加メタデータを加えます。
<a name="schemaExternalDocs"></a>externalDocs | [External Documentation Object](#externalDocumentationObject) | このスキーマに関する追加外部ドキュメントです。
<a name="schemaExample"></a>example | Any | このスキーマの例を入れるための自由形式フィールドです。JSONやYAMLで自然に表現できない例を表現するために、必要なエスケープを使って文字列を使用することができます。
<a name="schemaDeprecated"></a> deprecated | `boolean` | スキーマが非推奨で移行すべきである（SHOULD）ことを指定します。デフォルト値は`false`です。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

###### <a name="schemaComposition"></a>コンポジションと継承（ポリモーフィズム）

OpenAPI SpecificationではJSON Schemaの`allOf`プロパティを使ってモデルを組み合わせたり拡張でき、事実上のモデルコンポジションを提供します。
`allOf`は *独立に* 検証され、ひとつのオブジェクトに合成されるオブジェクト定義の配列をとります。

コンポジションはモデルの拡張性を提供しますが、モデル間の階層を示すわけではありません。
ポリモーフィズムをサポートするために、OpenAPI Specificationは`discriminator`フィールドを追加しています。
`discriminator`フィールドを使用すると、`discriminator`の値はモデルの構造を決定するスキーマ定義のプロパティの名前になります。
そのため、`discriminator`フィールドは必須フィールドでなければなりません（MUST）。
継承したインスタンスの`discriminator`の値を定義する方法は二通りあります。
- スキーマ名を使用する。
- 新しい値を持ったプロパティでオーバーライドすることでスキーマ名をオーバーライドする。新しい値が存在する時、スキーマ名より優先されます。
よって、インラインスキーマ定義はIDを持たないためにポリモーフィズムで *使用できません* 。

###### XMLモデリング

[xml](#schemaXml)プロパティによってJSON定義をXMLに変換するときの追加定義ができます。
[XML Object](#xmlObject)は使用可能なオプションに関する追加情報を持ちます。

##### Schema Objectの例

###### プリミティブのサンプル

```json
{
  "type": "string",
  "format": "email"
}
```

```yaml
type: string
format: email
```

###### シンプルなモデル

```json
{
  "type": "object",
  "required": [
    "name"
  ],
  "properties": {
    "name": {
      "type": "string"
    },
    "address": {
      "$ref": "#/components/schemas/Address"
    },
    "age": {
      "type": "integer",
      "format": "int32",
      "minimum": 0
    }
  }
}
```

```yaml
type: object
required:
- name
properties:
  name:
    type: string
  address:
    $ref: '#/components/schemas/Address'
  age:
    type: integer
    format: int32
    minimum: 0
```

###### マップ・辞書プロパティを持ったモデル

単純な文字列ー文字列マップの例

```json
{
  "type": "object",
  "additionalProperties": {
    "type": "string"
  }
}
```

```yaml
type: object
additionalProperties:
  type: string
```

文字列ーモデルマップの例

```json
{
  "type": "object",
  "additionalProperties": {
    "$ref": "#/components/schemas/ComplexModel"
  }
}
```

```yaml
type: object
additionalProperties:
  $ref: '#/components/schemas/ComplexModel'
```

###### 例つきのモデル

```json
{
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int64"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "name"
  ],
  "example": {
    "name": "Puma",
    "id": 1
  }
}
```

```yaml
type: object
properties:
  id:
    type: integer
    format: int64
  name:
    type: string
required:
- name
example:
  name: Puma
  id: 1
```

###### コンポジションを使用したモデル

```json
{
  "components": {
    "schemas": {
      "ErrorModel": {
        "type": "object",
        "required": [
          "message",
          "code"
        ],
        "properties": {
          "message": {
            "type": "string"
          },
          "code": {
            "type": "integer",
            "minimum": 100,
            "maximum": 600
          }
        }
      },
      "ExtendedErrorModel": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ErrorModel"
          },
          {
            "type": "object",
            "required": [
              "rootCause"
            ],
            "properties": {
              "rootCause": {
                "type": "string"
              }
            }
          }
        ]
      }
    }
  }
}
```

```yaml
components:
  schemas:
    ErrorModel:
      type: object
      required:
      - message
      - code
      properties:
        message:
          type: string
        code:
          type: integer
          minimum: 100
          maximum: 600
    ExtendedErrorModel:
      allOf:
      - $ref: '#/components/schemas/ErrorModel'
      - type: object
        required:
        - rootCause
        properties:
          rootCause:
            type: string
```

###### ポリモーフィズムをサポートしたモデル

```json
{
  "components": {
    "schemas": {
      "Pet": {
        "type": "object",
        "discriminator": {
          "propertyName": "petType"
        },
        "properties": {
          "name": {
            "type": "string"
          },
          "petType": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "petType"
        ]
      },
      "Cat": {
        "description": "猫の表現。discriminatorの値には`Cat`が使用されることに注意。",
        "allOf": [
          {
            "$ref": "#/components/schemas/Pet"
          },
          {
            "type": "object",
            "properties": {
              "huntingSkill": {
                "type": "string",
                "description": "狩り能力の計測値",
                "default": "lazy",
                "enum": [
                  "clueless",
                  "lazy",
                  "adventurous",
                  "aggressive"
                ]
              }
            },
            "required": [
              "huntingSkill"
            ]
          }
        ]
      },
      "Dog": {
        "description": "犬の表現。discriminatorの値には`Dog`が使用されることに注意。",
        "allOf": [
          {
            "$ref": "#/components/schemas/Pet"
          },
          {
            "type": "object",
            "properties": {
              "packSize": {
                "type": "integer",
                "format": "int32",
                "description": "犬の出身群れの規模",
                "default": 0,
                "minimum": 0
              }
            },
            "required": [
              "packSize"
            ]
          }
        ]
      }
    }
  }
}
```

```yaml
components:
  schemas:
    Pet:
      type: object
      discriminator:
        propertyName: petType
      properties:
        name:
          type: string
        petType:
          type: string
      required:
      - name
      - petType
    Cat:  ## discriminatorの値に"Cat"が使用される
      description: 猫の表現
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          huntingSkill:
            type: string
            description: 狩り能力の計測値
            enum:
            - clueless
            - lazy
            - adventurous
            - aggressive
        required:
        - huntingSkill
    Dog:  ## discriminatorの値に"Dog"が使用される
      description: 犬の表現
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          packSize:
            type: integer
            format: int32
            description: 犬の出身群れの規模
            default: 0
            minimum: 0
        required:
        - packSize
```

#### <a name="discriminatorObject"></a>Discriminator Object

リクエストボディやレスポンスペイロードがいくつかの異なるスキーマのうちの一つであるような場合、シリアライズ・デシリアライズ・バリデーションの補助のために`discriminator`オブジェクトを使用できます。
discriminatorは仕様書の利用者に対象の値に基づいた選択可能なスキーマについて知らせるようなスキーマ内の特定のオブジェクトです。

discriminatorを使用している際、_インラインの_ スキーマは考慮されません。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="propertyName"></a>propertyName | `string` | **REQUIRED**. ペイロード内でdiscriminatorの値を持つプロパティの名前
<a name="discriminatorMapping"></a> mapping | Map[`string`, `string`] | ペイロード値とスキーマ名・参照のマッピングを保有するオブジェクト

Discriminator Objectはコンポジションキーワード`oneOf`、`anyOf`、`allOf`のいずれかを使用していなければ適切ではありません。

OAS 3.0では、レスポンスペイロードはあらゆる数の型の中のちょうど一つで説明することができます（MAY）。

```yaml
MyResponseType:
  oneOf:
  - $ref: '#/components/schemas/Cat'
  - $ref: '#/components/schemas/Dog'
  - $ref: '#/components/schemas/Lizard'
```

これは、ペイロードはバリデーションによって`Cat`、`Dog`、`Lizard`のいずれかで定義されているスキーマのなかの一つのみに合致しなければならない（_MUST_）という意味です。
このケースでは、discriminatorは合致するスキーマをバリデーションして選択するという、スキーマ定義によってはコストのかかる操作のショートカットのための「ヒント」として働きます。
そうすれば、どのスキーマを使用するかを決定するフィールドがどれであるかを正確に表現することができます。

```yaml
MyResponseType:
  oneOf:
  - $ref: '#/components/schemas/Cat'
  - $ref: '#/components/schemas/Dog'
  - $ref: '#/components/schemas/Lizard'
  discriminator:
    propertyName: petType
```

この例で期待されることは`petType`という名前のプロパティがレスポンスペイロード内に存在しなければならず（_MUST_）、値はOASドキュメントで定義したスキーマの名前と対応していることです。よって次のレスポンスペイロード

```json
{
  "id": 12345,
  "petType": "Cat"
}
```

は`Cat`スキーマがこのペイロードの結合に使用されることを示しています。

`discriminator`フィールドの値がスキーマ名に一致せず暗黙的マッピングが不可能な場合、
オプションの`mapping`定義を使用できます（MAY）。

```yaml
MyResponseType:
  oneOf:
  - $ref: '#/components/schemas/Cat'
  - $ref: '#/components/schemas/Dog'
  - $ref: '#/components/schemas/Lizard'
  - $ref: 'https://gigantic-server.com/schemas/Monster/schema.json'
  discriminator:
    propertyName: petType
    mapping:
      dog: '#/components/schemas/Dog'
      monster: 'https://gigantic-server.com/schemas/Monster/schema.json'
```

ここで`dog`の値の`discriminator`は（暗黙の）デフォルト値`Dog`ではなくスキーマ`#components/schemad/Dog`にマップします。
`discriminator`の _値_ が暗黙的・明示的マップにマッチしないとき、スキーマは特定されずバリデーションは失敗すべきです（SHOULD）。
マップのキーは文字列値でなければならず（MUST）、一方ツールはレスポンスの値を比較のために文字列に変換してもよいです（MAY）。

`anyOf`構成での結合の中で使用されるとき、discriminatorの使用により単一のペイロードが複数のスキーマを満たすような曖昧さを回避できます。

`oneOf`と`anyOf`の両方のユースケースにおいて、ありうるスキーマは明示的に列挙されていなければなりません（MUST）。
冗長さを避けるため、discriminatorを親スキーマ定義に追加してもよく（MAY）、 `allOf`構造内で親スキーマを構成するすべてのスキーマは代替のスキーマとして使用できます。

例

```yaml
components:
  schemas:
    Pet:
      type: object
      required:
      - petType
      properties:
        petType:
          type: string
      discriminator:
        propertyName: petType
        mapping:
          dog: Dog
    Cat:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        # `Cat`特有の他の全てのプロパティ
        properties:
          name:
            type: string
    Dog:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        # `Dog`特有の他の全てのプロパティ
        properties:
          bark:
            type: string
    Lizard:
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        # `Lizard`特有の他の全てのプロパティ
        properties:
          lovesRocks:
            type: boolean
```

次のようなペイロード

```json
{
  "petType": "Cat",
  "name": "misty"
}
```

は`Cat`スキーマが使用されることを示しており、同様にこのスキーマ

```json
{
  "petType": "dog",
  "bark": "soft"
}
```

は`mappings`要素の定義に従って`Dog`にマップします。


#### <a name="xmlObject"></a>XML Object

XMLモデル定義向けに調整されたメタデータオブジェクトです。

配列を使用している時、XML要素名は（単数形・複数形が）推論され _ず_ 、`name`プロパティはその情報を加えるために使用されるべきです（SHOULD）。
期待される振る舞いについては例を参考にしてください。

##### 固定フィールド
フィールド名 | 型 | 説明
---|:---:|---
<a name="xmlName"></a>name | `string` | 記述されたスキーマプロパティに使用されている要素・属性の名前を入れ替えます。`items`内で定義されているとき、リスト内の特定のXML要素の名前に反映されます。`array`である`type`とともに定義されている場合（`items`の外）、`wrapped`が`true`である場合のみラップしている要素に反映されます。 `wrapped`が`false`の場合、無視されます。
<a name="xmlNamespace"></a>namespace | `string` | ネームスペース定義のURIです。値は絶対URI形式でなければなりません（MUST）。
<a name="xmlPrefix"></a>prefix | `string` | [name](#xmlName)に使用される接頭辞です。
<a name="xmlAttribute"></a>attribute | `boolean` | プロパティ定義が要素の代わりに属性に変換されるかどうかを宣言します。デフォルトは`false`です。
<a name="xmlWrapped"></a>wrapped | `boolean` | 配列定義でのみ使用できます（MAY）。配列がラップされている（例：`<books><book></book><books>`）かラップされていない（例：`<book></book>`）かを示します。デフォルト値は`false`です。これは`array`である`type`とともに（`items`の外）定義した場合のみ効果があります。 

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### XML Objectの例

XML表現のサンプルを持った[Schema Object](#schemaObject)の定義プロパティ内に含まれるXMLオブジェクト定義の例です。

###### XML要素が無い場合

基本的な文字列プロパティの例です。

```json
{
    "animals": {
        "type": "string"
    }
}
```

```yaml
animals:
  type: string
```

```xml
<animals>...</animals>
```

基本的な文字列配列プロパティの例です（[`wrapped`](#xmlWrapped)はデフォルトで`false`です）。

```json
{
    "animals": {
        "type": "array",
        "items": {
            "type": "string"
        }
    }
}
```

```yaml
animals:
  type: array
  items:
    type: string
```

```xml
<animals>...</animals>
<animals>...</animals>
<animals>...</animals>
```

###### XML名置換

```json
{
  "animals": {
    "type": "string",
    "xml": {
      "name": "animal"
    }
  }
}
```

```yaml
animals:
  type: string
  xml:
    name: animal
```

```xml
<animal>...</animal>
```


###### XML属性と接頭辞とネームスペース

完全なモデル定義をこの例で示します。

```json
{
  "Person": {
    "type": "object",
    "properties": {
      "id": {
        "type": "integer",
        "format": "int32",
        "xml": {
          "attribute": true
        }
      },
      "name": {
        "type": "string",
        "xml": {
          "namespace": "http://example.com/schema/sample",
          "prefix": "sample"
        }
      }
    }
  }
}
```

```yaml
Person:
  type: object
  properties:
    id:
      type: integer
      format: int32
      xml:
        attribute: true
    name:
      type: string
      xml:
        namespace: http://example.com/schema/sample
        prefix: sample
```

```xml
<Person id="123">
    <sample:name xmlns:sample="http://example.com/schema/sample">example</sample:name>
</Person>
```

###### XML配列

属性名の変更。

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
```

```xml
<animal>value</animal>
<animal>value</animal>
```

XMLに影響を与えない外側`name`プロパティの例。

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "name": "aliens"
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    name: aliens
```

```xml
<animal>value</animal>
<animal>value</animal>
```

配列が割賦されていても、名前が明示的に宣言されていなければ、内側も外側も同じ名前が使用されます。

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "xml": {
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
  xml:
    wrapped: true
```

```xml
<animals>
  <animals>value</animals>
  <animals>value</animals>
</animals>
```

上記の例の名前問題を解決するために、次のような定義が使用できます。

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    wrapped: true
```

```xml
<animals>
  <animal>value</animal>
  <animal>value</animal>
</animals>
```

内側と外側の両方の名前を書き換える場合の例。

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string",
      "xml": {
        "name": "animal"
      }
    },
    "xml": {
      "name": "aliens",
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
    xml:
      name: animal
  xml:
    name: aliens
    wrapped: true
```

```xml
<aliens>
  <animal>value</animal>
  <animal>value</animal>
</aliens>
```

外側の要素だけ変更し内側には影響を与えない例。

```json
{
  "animals": {
    "type": "array",
    "items": {
      "type": "string"
    },
    "xml": {
      "name": "aliens",
      "wrapped": true
    }
  }
}
```

```yaml
animals:
  type: array
  items:
    type: string
  xml:
    name: aliens
    wrapped: true
```

```xml
<aliens>
  <aliens>value</aliens>
  <aliens>value</aliens>
</aliens>
```

#### <a name="securitySchemeObject"></a>Security Scheme Object

Security Scheme Objectは操作に使用できるセキュリティスキーマを定義します。
サポートされているスキーマはHTTP認証、APIキー（ヘッダー、クッキー、クエリパラメータのいずれも可）、[RFC6749](https://tools.ietf.org/html/rfc6749)で定義されたOAuth2の共通フロー（インプリシット、パスワード、アプリケーション、アクセスコード）、[OpenID Connect Discovery](https://tools.ietf.org/html/draft-ietf-oauth-discovery-06)です。

##### 固定フィールド
フィールド名 | 型 | 反映対象 | 説明
---|:---:|---|---
<a name="securitySchemeType"></a>type | `string` | Any | **REQUIRED**. セキュリティスキームの種類です。使用できる値は`"apiKey"`、`"http"`、`"oauth2"`、`"openIdConnect"`です。
<a name="securitySchemeDescription"></a>description | `string` | Any | セキュリティスキームの短い説明です。リッチなテキスト表現のために[CommonMark syntax](http://spec.commonmark.org/)を使用できます（MAY）。
<a name="securitySchemeName"></a>name | `string` | `apiKey` | **REQUIRED**. 使用するヘッダ、クエリ、クッキーパラメータの名前です。
<a name="securitySchemeIn"></a>in | `string` | `apiKey` | **REQUIRED**. APIキーの場所です。使用できる値は`"query"`、`"header"`、`"cookie"`です。
<a name="securitySchemeScheme"></a>scheme | `string` | `http` | **REQUIRED**. [Authorization header as defined in RFC7235](https://tools.ietf.org/html/rfc7235#section-5.1)で使用されているHTTP認証スキームの名前です。
<a name="securitySchemeBearerFormat"></a>bearerFormat | `string` | `http` (`"bearer"`) | Bearerトークンがどのような形式なのかのクライアントへのヒントです。Bearerトークンは通常認証サーバーに生成されるため、この情報はドキュメンテーションのためにあります。
<a name="securitySchemeFlows"></a>flows | [OAuth Flows Object](#oauthFlowsObject) | `oauth2` | **REQUIRED**. サポートフロー種別の設定情報を含んだオブジェクトです。
<a name="securitySchemeOpenIdConnectUrl"></a>openIdConnectUrl | `string` | `openIdConnect` | **REQUIRED**. OAuth2設定値を見るためのOpenId Connect URLです

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### Security Scheme Objectの例

###### ベーシック認証のサンプル

```json
{
  "type": "http",
  "scheme": "basic"
}
```

```yaml
type: http
scheme: basic
```

###### APIキーのサンプル

```json
{
  "type": "apiKey",
  "name": "api_key",
  "in": "header"
}
```

```yaml
type: apiKey
name: api_key
in: header
```

###### JWT Bearerのサンプル

```json
{
  "type": "http",
  "scheme": "bearer",
  "bearerFormat": "JWT",
}
```

```yaml
type: http
scheme: bearer
bearerFormat: JWT
```

###### インプリシットOAuth2のサンプル

```json
{
  "type": "oauth2",
  "flows": {
    "implicit": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "scopes": {
        "write:pets": "あなたのアカウントのペットを編集します。",
        "read:pets": "あなたのペットを読み込みます。"
      }
    }
  }
}
```

```yaml
type: oauth2
flows: 
  implicit:
    authorizationUrl: https://example.com/api/oauth/dialog
    scopes:
      write:pets: あなたのアカウントのペットを編集します。
      read:pets: あなたのペットを読み込みます。
```

#### <a name="oauthFlowsObject"></a>OAuth Flows Object

OAuth Flows ObejectによりサポートするOAuthフローの設定ができます。

##### 固定フィールド
フィールド名 |型 | 説明
---|:---:|---
<a name="oauthFlowsImplicit"></a>implicit| [OAuth Flow Object](#oauthFlowObject) | OAuthのインプリシットフローの設定です。
<a name="oauthFlowsPassword"></a>password| [OAuth Flow Object](#oauthFlowObject) | OAuthのパスワードフローの設定です。
<a name="oauthFlowsClientCredentials"></a>clientCredentials| [OAuth Flow Object](#oauthFlowObject) | OAuthのクライアントクレデンシャルフローの設定です。 かつてOpenAPI 2.0では`application`と呼ばれていたものです。
<a name="oauthFlowsAuthorizationCode"></a>authorizationCode| [OAuth Flow Object](#oauthFlowObject) | OAuthのオーソライゼーションコードフローの設定です。かつてOpenAPI 2.0では`accessCode`と呼ばれていたものです。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

#### <a name="oauthFlowObject"></a>OAuth Flow Object

サポートするOAuthフローの詳細設定です。
Configuration details for a supported OAuth Flow

##### 固定フィールド
フィールド名 | 型 | 反映対象 | 設定
---|:---:|---|---
<a name="oauthFlowAuthorizationUrl"></a>authorizationUrl | `string` | `oauth2` (`"implicit"`, `"authorizationCode"`) | **REQUIRED**. このフローで使用する認証URL。これはURLの形式でなければなりません（MUST）。
<a name="oauthFlowTokenUrl"></a>tokenUrl | `string` | `oauth2` (`"password"`, `"clientCredentials"`, `"authorizationCode"`) | **REQUIRED**. このフローで使用するトークンURLです。これはURLの形式でなければなりません（MUST）。
<a name="oauthFlowRefreshUrl"></a>refreshUrl | `string` | `oauth2` | リフレッシュトークンを取得するためのURLです。これはURLの形式でなければなりません（MUST）。
<a name="oauthFlowScopes"></a>scopes | Map[`string`, `string`] | `oauth2` | **REQUIRED**. OAuth2 security schemeの使用できるスコープです。スコープ名と短い説明のマップです。

このオブジェクトは[Specification Extensions](#specificationExtensions)によって拡張することができます（MAY）。

##### OAuth Flow Objectの例

```JSON
{
  "type": "oauth2",
  "flows": {
    "implicit": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "scopes": {
        "write:pets": "あなたのアカウントのペットを編集します。",
        "read:pets": "あなたのペットを読み込みます。"
      }
    },
    "authorizationCode": {
      "authorizationUrl": "https://example.com/api/oauth/dialog",
      "tokenUrl": "https://example.com/api/oauth/token",
      "scopes": {
        "write:pets": "あなたのアカウントのペットを編集します。",
        "read:pets": "あなたのペットを読み込みます。"
      }
    }
  }
}
```

```yaml
type: oauth2
flows: 
  implicit:
    authorizationUrl: https://example.com/api/oauth/dialog
    scopes:
      write:pets: あなたのアカウントのペットを編集します。
      read:pets: あなたのペットを読み込みます。
  authorizationCode:
    authorizationUrl: https://example.com/api/oauth/dialog
    tokenUrl: https://example.com/api/oauth/token
    scopes:
      write:pets: あなたのアカウントのペットを編集します。
      read:pets: あなたのペットを読み込みます。
```


#### <a name="securityRequirementObject"></a>Security Requirement Object

この操作を実行するために要求されるセキュリティスキーマのリストです。

各プロパティに使用する名前は[Components Object](#componentsObject)内の[Security Schemes](#componentsSecuritySchemes)に定義したセキュリティスキーマと対応していなければなりません（MUST）。

複数のスキーマを含んだSecurity Requirement Objectはリクエストを認証するために全てのスキーマを満たさなければならない（MUST）ことを要求します。
これによりセキュリティ情報を伝送するために複数のクエリパラメータやHTTPヘッダを要求するようなシナリオをサポートできます。

Security Requirement Objectのリストが[OpenAPI Object](#oasObject)や[Operation Object](#operationObject)で定義されているとき、リスト内のSecurity Requirement Objectのうちのひとつだけ満たすことでリクエストが認証されます。

##### パターンフィールド

フィールドパターン | 型 | 説明
---|:---:|---
<a name="securityRequirementsName"></a>{name} | [`string`] | 各名前は[Components Object](#componentsObject)内の[Security Schemes](#componentsSecuritySchemes)で定義されたセキュリティスキームと対応していなければなりません（MUST）。セキュリティスキーマが`"oauth2"`または`"openIdConnect"`型の場合、値は実行に必要なスコープ名のリストです。他のセキュリティスキーマ型については、配列は空でなければなりません（MUST）。

##### Security Requirement Objectの例

###### OAuth2ではないSecurity Requirement

```json
{
  "api_key": []
}
```

```yaml
api_key: []
```

###### OAuth2のSecurity Requirement

```json
{
  "petstore_auth": [
    "write:pets",
    "read:pets"
  ]
}
```

```yaml
petstore_auth:
- write:pets
- read:pets
```

### <a name="specificationExtensions"></a>Specification Extensions

OpenAPI Specificationはほとんどのユースケースに適応しようとしていますが、いくらかの点で仕様書を拡張するためにデータを追加できます。

拡張プロパティは常に接頭辞`"x-"`のついたパターンフィールドとして実装されます。

Field Pattern | Type | Description
---|:---:|---
<a name="infoExtensions"></a>^x- | Any | OpenAPIスキーマを拡張できます。フィールド名は例えば`"x-internal-id`"のように`"x-"`で始まらなければなりません（MUST）。値は`null`、プリミティブ、配列、オブジェクトが使用できます。JSONフォーマットとしてただしい値が全て使用できます。

拡張はツールによってサポートされることもされないこともあるが、これらは要求されたサポートの追加をするように拡張されることもある（ツールが内部ツールまたはOSSの場合）。

### <a name="securityFiltering"></a>Security Filtering

OpenAPI Specificationのいくつかのオブジェクトは空のままに設定したり、完全に削除したりできます（MAY）が、これらは本質的にAPIドキュメントのコアです。

理由はドキュメンテーションのアクセス制御の追加レイヤを使用するためです。
仕様書自身の一部でなくても、ライブラリは何らかの形式の認証・認可に基づいてドキュメントの一部のアクセスを許可することを選択できます（MAY）。

2つの例を挙げます。

1. [Paths Object](#pathsObject)は空でもよいです（MAY）。これは直感に反しますが、閲覧者が正しい場所を見ているもののあらゆるドキュメントにアクセスできないことを伝えられます。
2. [Path Item Object](#pathItemObject)は空でもよいです（MAY）。このケースでは、閲覧者はパスが存在することを知ることができますが、その操作やパラメータについて何も見ることができません。これは[Paths Object](#pathObject)からパス自体を隠すことと異なり、ユーザーはその存在を知ることができません。これにより閲覧者が何を見ることができるのかを提供者が細かく制御できます。

## <a name="revisionHistory"></a>Appendix A: Revision History

Version   | Date       | Notes
---       | ---        | ---
3.0.2     | 2018-10-08 | Patch release of the OpenAPI Specification 3.0.2
3.0.1     | 2017-12-06 | Patch release of the OpenAPI Specification 3.0.1
3.0.0     | 2017-07-26 | Release of the OpenAPI Specification 3.0.0
3.0.0-rc2 | 2017-06-16 | rc2 of the 3.0 specification
3.0.0-rc1 | 2017-04-27 | rc1 of the 3.0 specification
3.0.0-rc0 | 2017-02-28 | Implementer's Draft of the 3.0 specification
2.0       | 2015-12-31 | Donation of Swagger 2.0 to the Open API Initiative
2.0       | 2014-09-08 | Release of Swagger 2.0
1.2       | 2014-03-14 | Initial release of the formal document.
1.1       | 2012-08-22 | Release of Swagger 1.1
1.0       | 2011-08-10 | First release of the Swagger Specification
